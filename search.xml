<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring Boot+Dubbo+Zookeeper简单集成分布式]]></title>
    <url>%2F2019%2F03%2F27%2FSpringBoot-Dubbo-Zookeper%2F</url>
    <content type="text"><![CDATA[Spring Boot+Dubbo+Zookeeper简单集成分布式dubbo是阿里公司推出解决分布式服务问题的框架，是一个基于SOA面向服务体系结构的基础设施，提供了诸如服务发布注册、容错调用、部署、调用次数监控、每个服务的性能监控等很多功能。 Dubbo建议使用Zookeeper作为服务的注册中心。 Zookeeper的作用： ​ zookeeper用来注册服务和进行负载均衡，哪一个服务由哪一个机器来提供必需让调用者知道，简单来说就是ip地址和服务名称的对应关系。当然也可以 通过硬编码的方式把这种对应关系在调用方业务代码中实现，但是如果提供服务的机器挂掉调用者无法知晓，如果不更改代码会继续请求挂掉的机器提供服务。 zookeeper通过心跳机制可以检测挂掉的机器并将挂掉机器的ip和服务对应关系从列表中删除。至于支持高并发，简单来说就是横向扩展，在不更改代码 的情况通过添加机器来提高运算能力。通过添加新的机器向zookeeper注册服务，服务的提供者多了能服务的客户就多了。 dubbo： ​ 是管理中间层的工具，在业务层到数据仓库间有非常多服务的接入和服务提供者需要调度，dubbo提供一个框架解决这个问题。 ​ 注意这里的dubbo只是一个框架，至于你架子上放什么是完全取决于你的，就像一个汽车骨架，你需要配你的轮子引擎。这个框架中要完成调度必须要有一个分布式的注册中心，储存所有服务的元数据，你可以用zk，也可以用别的，只是大家都用zk。 zookeeper和dubbo的关系： ​ Dubbo的将注册中心进行抽象，是得它可以外接不同的存储媒介给注册中心提供服务，有ZooKeeper，Memcached，Redis等。 ​ 引入了ZooKeeper作为存储媒介，也就把ZooKeeper的特性引进来。首先是负载均衡，单注册中心的承载能力是有限的，在流量达到一定程度的时 候就需要分流，负载均衡就是为了分流而存在的，一个ZooKeeper群配合相应的Web应用就可以很容易达到负载均衡；资源同步，单单有负载均衡还不 够，节点之间的数据和资源需要同步，ZooKeeper集群就天然具备有这样的功能；命名服务，将树状结构用于维护全局的服务地址列表，服务提供者在启动 的时候，向ZK上的指定节点/dubbo/${serviceName}/providers目录下写入自己的URL地址，这个操作就完成了服务的发布。 其他特性还有Mast选举，分布式锁等。下面是简单的实现Spring Boot+Dubbo+Zookeeper简单集成 1.首先在win或linux下安装zookeeper，这里以win环境下进行安装Zookeeper. 在官网https://mirrors.cnnic.cn/apache/zookeeper/下载zookeeper. 把下载的zookeeper的文件解压到指定目录 1234567891011121314151617D:\machine\zookeeper-3.3.6&gt;修改conf下增加一个zoo.cfg内容如下：# The number of milliseconds of each tick 心跳间隔 毫秒每次tickTime=2000# The number of ticks that the initial# synchronization phase can takeinitLimit=10# The number of ticks that can pass between# sending a request and getting anacknowledgementsyncLimit=5# the directory where the snapshot isstored. //镜像数据位置dataDir=D:\\data\\zookeeper#日志位置dataLogDir=D:\\logs\\zookeeper# the port at which the clients willconnect 客户端连接的端口clientPort=2181 注：如果启动有报错提示cfg文件有错误，可以用zoo_sample.cfg内内容替代也是可以的 进入到bin目录，并且启动zkServer.cmd，这个脚本中会启动一个java进程 123D:\machine\zookeeper-3.3.6&gt;cd binD:\machine\zookeeper-3.3.6\bin&gt;D:\machine\zookeeper-3.3.6\bin &gt;zkServer.cmd 2.创建生产者及消费者demo目录格式如下： 将必须的jar导入到dubbo及dubboapi的pom.xml中 123456789101112131415161718192021222324&lt;!--引入zookeeper--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入dubbo--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--引入zookeeper客户端--&gt;&lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.10&lt;/version&gt;&lt;/dependency&gt; 3.dubbo配置文件分别在服务端和消费端下的resources下创建provider.xml及customer.xml provider.xml: 12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"&gt; &lt;!--配置服务名称--&gt; &lt;dubbo:application name="provider" /&gt; &lt;!--配置服务注册中心，dubbo不仅仅支持zookeeper--&gt; &lt;dubbo:registry address="zookeeper://127.0.0.1:2181" /&gt; &lt;!--声明对外暴露的服务--&gt; &lt;dubbo:service interface="com.example.dubbo.service.UserService" ref="UserService" /&gt; &lt;bean id="demoService" class="com.example.dubbo.service.impl.UserServiceImpl"&gt;&lt;/bean&gt;&lt;/beans&gt; customer.xml:这里配置和provider.xml的时候有点不一样，不用注入bean 123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"&gt; &lt;!--配置服务名称--&gt; &lt;dubbo:application name="customer" /&gt; &lt;!--配置服务注册中心，dubbo不仅仅支持zookeeper--&gt; &lt;dubbo:registry address="zookeeper://127.0.0.1:2181" /&gt; &lt;!--声明服务引用，与服务声明接口类型一致--&gt; &lt;dubbo:reference interface="com.example.dubbo.service.UserService" id="UserService" /&gt;&lt;/beans&gt; 4.编写测试类这里的接口与实体类是服务端和客户端共同都有的 编写po： 1234567891011121314151617package com.example.dubbo.po;import lombok.Data;import java.io.Serializable;/** * @Description : * @Author : 苏俊强 * @Date : 2019/3/25 */@Datapublic class User implements Serializable &#123; private static final long serialVersionUID = 1L; private int id; private String password;&#125; 编写service 12345678910111213package com.example.dubbo.service;import com.example.dubbo.po.User;/** * @Description : * @Author : 苏俊强 * @Date : 2019/3/25 */public interface UserService &#123; User selectUserById(int id);&#125; 在服务端编写impl 123456789101112131415161718192021package com.example.dubbo.service.impl;import com.example.dubbo.po.User;import com.example.dubbo.service.UserService;import org.springframework.stereotype.Service;/** * @Description : * @Author : 苏俊强 * @Date : 2019/3/25 */@Service("UserService")public class UserServiceImpl implements UserService &#123; @Override public User selectUserById(int id) &#123; System.out.println("这里是dubbo的服务端"); System.out.println("需要查询的用户为" + id); return null; &#125;&#125; 在客户端编写controller 1234567891011121314151617181920212223242526package com.example.dubbo.controller;import com.example.dubbo.po.User;import com.example.dubbo.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;/** * @Description : * @Author : 苏俊强 * @Date : 2019/3/25 */@RestControllerpublic class UserController &#123; @Autowired private UserService userService; @GetMapping("selectUserById/&#123;id&#125;") public String selectUserById(@PathVariable("id") int id)&#123; System.out.println(id); User user= userService.selectUserById(id); return "ok"; &#125;&#125; 至于如何使用dubbo-admin 监控搭建，读者可参考https://blog.csdn.net/evankaka/article/details/47858707 源码下载https://github.com/su-junqiang/dubbo-zookeper-demo.git]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux安装jdk1.8&&设置Tomcat为开机启动服务&&MySQL外网访问&&redis安装配置]]></title>
    <url>%2F2019%2F01%2F01%2Flinux%26%26jdk%26%26mysql%26%26redis%2F</url>
    <content type="text"><![CDATA[linux安装jdk1.8解压jdk安装包：附上jdk1.8的下载地址：http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 将jdk-8u192-linux-x64.tar.gz下载到本地用xftp将其上传至xshell中自己指定的下载目录 使用以下命令将其解压 12tar -zxvf jdk1.8.0_191.tar.gz //解压安装包到当前文件夹 mv jdk1.8.0_191 java1.8 //重命名 之后配置一下环境变量。 编辑/etc/下的profile文件，配置环境变量 1sudo vi /etc/profile // 到profile配置环境变量 在profile文件添加以下内容 123export JAVA_HOME=/root/server/jdk1.8 //jdk1.8的目录 export JRE_HOME=$&#123;JAVA_HOME&#125;/jre export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 之后保存并退出文件之后在控制台输入Java 和 Java -version 看有没有信息输出，如下： 12java -version java version &quot;1.8.0_191&quot; //版本号 Java(TM) SE Runtime Environment (build 1.8.0_191-b12) Java HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode) 能显示以上信息，就说明jdk安装成功啦 linux设置Tomcat为开机启动服务解压tomcat安装包附上tomcat8的下载地址https://tomcat.apache.org/download-80.cgi 将tar.gz (pgp, sha512)下载到本地用xftp将其上传至xshell中自己指定的下载目录 使用以下命令将其解压 12tar -zxvf apache-tomcat-8.5.35.tar.gz //解压安装包到当前文件夹 mv apache-tomcat-8.5.35 tomcat8 //重命名 将tomcat安装目录下bin文件夹中的catalina.sh拷贝到/etc/init.d下并修改名称为tomcat 12cp /tomcat8/bin/catalina.sh /etc/init.d/ mv /etc/init.d/catalina.sh tomcat //将服务重命名为tomcat 分别执行上面三条命令，如果提示错误在开头加上sudo，然后配置/etc/init.d/tomcat添加以下内容 12CATALINA_HOME=/root/server/tomcat8 //tomcat8的目录 JAVA_HOME=/root/server/jdk1.8 //jdk1.8的目录 CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$CATALINA_HOME/lib 之后保存并退出文件之后进行添加开机自启服务 1234apt install sysv-rc-conf //首先安装sysv-rc-conf update-rc.d –f tomcat remove sysv-rc-conf tomcat on sysv-rc-conf tomcat --list 重启 12reboot netstat -ntlp //查看端口8080是否启动 linux设置MySQL外网访问通过apt-get安装mysql 123sudo apt-get install mysql-server apt-get install mysql-client apt-get install mysql-client 进入MySQL配置允许外网访问 123mysql -uroot -p //输入密码 use mysql select host,user from user; 实现远程连接(授权法)将host字段的值改为%就表示在任何客户端机器上能以root用户登录到mysql服务器，建议在开发时设为%。 12update user set host=&apos;%&apos; where user=&apos;root&apos;;flush privileges; 授权用户 任意主机以用户root和密码mypwd连接到mysql服务器 1GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;mypwd&apos; WITH GRANT OPTION; flush privileges; IP为192.168.1.102的主机以用户myuser和密码mypwd连接到mysql服务器 12GRANT ALL PRIVILEGES ON *.* TO &apos;myuser&apos;@&apos;192.168.1.102&apos; IDENTIFIED BY &apos;mypwd&apos; WITH GRANT OPTION; flush privileges; linux安装配置redis通过wget下载redis的压缩包12wget http://download.redis.io/releases/redis-5.0.3.tar.gz //redis wget下载 tar xzf redis-5.0.3.tar.gz //解压redis包 进入redis-5.0.3下的src目录 1cd redis-5.0.3/src make install PREFIX=/usr/local/redis //注意:make编译如果失败，因为没有安装gcc服务 安装gcc服务，之后提示下载文件y确认 1yum install gcc 输入 make PREFIX=/usr/local/redis install 安装redis 到 目录 /usr/local/redis 123456Hint: It&apos;s a good idea to run &apos;make test&apos; ;) INSTALL install INSTALL install INSTALL install INSTALL install INSTALL install 以上提醒表明安装成功。 进入安装目录，查看 bin 目录下的文件 123cd /usr/local/redis/bin ls redis-benchmark redis-check-aof redis-check-rdb redis-cli redis-sentinel redis-server 其中： redis-benchmark —-性能测试工具 redis-check-aof —-AOF文件修复工具 redis-check-dump —-RDB文件检查工具（快照持久化文件） redis-cli —-命令行客户端 redis-server —-redis服务器启动命令 配置 redis.conf,进入一开始解压的文件夹 1cd /root/server/redis ls cp redis.conf /usr/local/redis/ 修改redis.conf配置文件 1sudo vi redis.conf daemonize yes 将 daemonize no 修改为 daemonize yes 这样便可以以后端模式启动 启动redis服务 进入安装目录 /usr/local/redis/ ，命令行： cd /usr/local/redis/ 1./bin/redis-server ./redis.conf]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Linux</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不同的 SQL JOIN]]></title>
    <url>%2F2018%2F12%2F29%2FSql%26%26Join%2F</url>
    <content type="text"><![CDATA[INNER JOIN内连接是最常见的一种连接，只连接匹配的行。 inner join语法 1select column_name(s) from table 1 INNER JOIN table 2 ON table 1.column_name=table 2.column_name 注释：INNER JOIN与JOIN是相同 INNER JOIN产生的结果集中，是1和2的交集。 LEFT JOIN返回左表的全部行和右表满足ON条件的行，如果左表的行在右表中没有匹配，那么这一行右表中对应数据用NULL代替。 LEFT JOIN 语法 1select column_name(s) from table 1 LEFT JOIN table 2 ON table 1.column_name=table 2.column_name 注释：在某些数据库中，LEFT JOIN 称为LEFT OUTER JOIN LEFT JOIN产生表1的完全集，而2表中匹配的则有值，没有匹配的则以null值取代。 RIGHT JOINRIGHT JOIN返回右表的全部行和左表满足ON条件的行，如果右表的行在左表中没有匹配，那么这一行左表中对应数据用NULL代替。 RIGHT JOIN语法 1select column_name(s) from table 1 RIGHT JOIN table 2 ON table 1.column_name=table 2.column_name 注释：在某些数据库中，RIGHT JOIN 称为RIGHT OUTER JOIN RIGHT JOIN产生表2的完全集，而1表中匹配的则有值，没有匹配的则以null值取代。 FULL JOIN会从左表 和右表 那里返回所有的行。如果其中一个表的数据行在另一个表中没有匹配的行，那么对面的数据用NULL代替 FULL OUTER JOIN语法 1select column_name(s) from table 1 FULL OUTER JOIN table 2 ON table 1.column_name=table 2.column_name FULL OUTER JOIN产生1和2的并集。但是需要注意的是，对于没有匹配的记录，则会以null做为值。]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中的for循环与SQL]]></title>
    <url>%2F2018%2F12%2F29%2Fjava%26%26for%2F</url>
    <content type="text"><![CDATA[java中的for循环基础的for循环123for (int i = 0; i &lt; players.size(); i++) &#123;System.out.println(players.get(i));&#125; 以前的循环方式123for (String player : players) &#123;System.out.print(player + ";\n ");&#125; 使用 lambda 表达式以及函数操作(functional operation)1players.forEach((player) -&gt; System.out.print(player + ";\n ")); 在 Java 8 中使用双冒号操作符(double colon operator)1players.forEach(System.out::println); Java数据类型和MySql数据类型对应表]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令详解]]></title>
    <url>%2F2018%2F12%2F29%2Fgit%26%26command%2F</url>
    <content type="text"><![CDATA[配置账号信息1234git config --global user.name ***git config --global user.email ***@***.***git config --list# 查看配置的信息git help config# 获取帮助信息 生成密钥1ssh-keygen -t rsa -C ***@***.*** 初始化初始化一个目录为工作目录1git init 向临时仓库添加文件’ . ‘表示全部添加，当你需要添加刚才所修改的所有文件时，就可用点表示。当然，你也可以添加具体某一文件，如git add a.doc 123git add . 创建新分支：git branch new_featuregit 切换到另一分支: checkout new_feature 向永久仓库提交文件add 命令是向git的临时仓库提交，临时仓库类似缓冲区，commit 表示真正的向代码库提交。 1git commit . -m &quot;注释部分&quot; 创建并切换分支建立分支是创建代码的独立版本的动作，独立于主干分支[主分支(名称叫做master)，即是我们干刚提交的分支，当你没有指定时，git会默认帮我们提交到主分支上。主分支是默认生成的，其它分支需要自己创建]。 创建并同时切换到你新建的分支，发送： 1git checkout -b new_feature 上面的命令我们可以分两步执行，先创建一个分支然后手动切换，就像这样： 如果要看在项目下所有的分支，发送这个： 1git branch 现在你可以在你的项目上无所顾忌地做任何你想做的：任何时候，你都可以回到你创建分支前的状态。 合并分支当我们对分支上的新功能满意了的时候，就需要把它加到主干分支上。当我们在自己的新功能分支上时，首先需要加载（stage）并且提交你的文件： 1git add .t commit -m &quot;adds my new feature&quot; 然后我们移到自己的主干分支： 1git checkout master 像这样合并： 1git merge new_feature 此时，你的主干分支和你的新功能分支会变成一样的。 版本回退git会帮你记录你的任何一次提交（所以，提交时写注释是很需要的，方便我们找回以前版本），何时切换了哪些分支等等。查看的命令很简单： 1git reflog 你会发现git是用一些不规律的16进制数代表一个版本，我们如果想回到某一个以前的版本，可以用下面的命令： 12git reset --hard 该版本的16进制数 (注：只需写前几位即可，git会自己去寻找) 如果不是特殊情况，我们应该很少去回退到特别古老的版本，最常用的莫过于对自己刚刚做的修改不满意，（在上一次commit之后做了修改，之后还没有做add和commit操作）想撤回到上一次的commit。你只需写一个命令即可回退到刚才commit的状态: 12git checkout -- . (特别注意：checkout后面是两杠-- 如果没有这两杠是什么？ 就是切换分支了！要特别注意！当然，--后面还需要 &apos; . &apos;， 表示全部撤回。) 标签12345678git tag v1.0# 新建标签 git tag -a v1.0 -m &apos;my version 1.0&apos;# 新建带注释标签 git checkout tagname# 切换到标签 git tag# 列出现有标签 push origin v1.5# 推送分支到源上 git push origin --tags# 一次性推送所有分支 git tag -d v1.0# 删除标签 git push origin :refs/tags/v1.0# 删除远程标签 上传文件到远程代码库之所以说git 强大，是因为我们刚刚所有的操作都是在本地完成的，不需要联网，不需要自己额外建库，这是svn，cvs等其它版本管理工具做不到的。但这样岂不是不能团队合作了？ 别急，这就有了github，bitbucket等网站，它们为开发者免费提供远程代码库。我们可以很方便的将自己的代码存储到上面，也可以很方便的将远程库的代码pull到本地，实现团队开发。 本地库与远程库进行绑定： 1git remote add origin git@server-name:path/repo-name.git 接着我们就向这个远程仓库提交代码： git push origin 本地分支名称:远程分支名称 (应该很好理解，push代表上传命令，‘ ： ’左边写上本地的需要上传的分支名称，右边写上将这个分支上传到服务的分支名称，) git push origin master (将本地的master分支推送到远程master分支上，是git push origin master:master的简写形式) 在团队开发的时候，当我们需要修改一个文件，为了不必要的麻烦，一定记得要将自己的本地文件更新到远程代码库的最新版本后再做修改。更新远程代码库很简单. 1git pull origin master 使用.gitignore文件 在一个项目中，往往有些文件是无需纳入 Git 管理的，比如自动生成的文件，像日志或者编译过程中创建的文件。我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件来解决这个问题。 注意1.以# 符号开始的行都会被git忽视 2.支持glob模式匹配（即简化了的正则表达式） 示例如下： 12345678910忽略所有 .tmp 结尾的文件*.tmp###### 但 main.tmp 除外!main.tmp###### 仅仅忽略项目根目录下的 note文件/note忽略 build/ 目录下的所有文件build/会忽略 doc/notes.txt 但不包括 doc/server/notes.txtdoc/notes.txt 其他技巧在Mac系统中，有一个很讨厌的文件叫做 .DS_Store,如果我们使用Mac系统一般会在项目初始化的时候将其加入`.gitignore，但有时候会因为从Windows迁移等原因导致忘记添加并且commit进仓库了。 这时候我们需要将其移出Git仓库，步骤如下: 12find . -name .DS_Store -print0 | xargs -0 git rm -f --ignore-unmatch 然后再将`.gitignore`里添加`.DS_Store`,重新commit即可。 对于这种常用却又比较长的命令，我习惯将其组装成函数加入bashrc中 123function cleands &#123; find . -name .DS_Store -print0 | xargs -0 git rm -f --ignore-unmatch &#125; 这样，执行cleands即可。 git 默认对于文件名大小写是不敏感的,要想修正这一点，使用如下配置： 1git config core.ignorecase false 有时候commit之后突然意识到commit的信息中有单词拼错之类，想做修改： 1git commit --amend Vim在安装Vundle插件后使用Vim来commit一些信息可能会报错如下 12error: There was a problem with the editor &apos;vi&apos;. Please supply the message using either -m or -F option. 解决方式： 1git config --global core.editor $(which vim) 想让git 的log信息看起来更geek？ 1git config --global alias.lg &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot; git lg 一下试试。 gitignore 全局配置 新建~/.gitignore文件： 12.DS\_Store *.swp 然后执行： 1$git config --global core.excludesfile ~/.gitignore .gitignore规则不生效 有些时候我们在clone一个项目编译后，往往ide会生成许多文件，我们需要将其加入.gitignore,但我们按照规则添加进去之后往往并不会生效，原因是.gitignore只能忽略那些原来没有被track的文件该文件只能作用于 Untracked Files，也就是那些从来没有被 Git 记录过的文件（自添加以后，从未 add 及 commit 过的文件)，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地 缓存删除（改变成未track状态）： 1git rm --cached ***]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo进阶高级功能配置]]></title>
    <url>%2F2018%2F12%2F19%2FHexo-config%2F</url>
    <content type="text"><![CDATA[进阶高级功能配置更多如外挂一样的功能配置，就直接贴大佬的文章了，哪些功能自己喜欢，按照大佬的教程来配置就行。不过也有坑，比如有些功能（超链接样式、侧栏头像圆形并旋转）可以直接通过在custom.styl添加 CSS 代码实现，无需更改其它文件！ hexo高阶教程next主题优化 hexo的next主题个性化教程:打造炫酷网站 Hexo搭建博客的个性化设置 第一篇文章内有 NexT 主题的文件目录说明，这对自己自定义博客有很大帮助。 更改上一篇，下一篇的顺序进入一篇文章，在文章底部，有上下篇的链接（&lt; &gt;），但是点 &gt; 发现进入的是页面中的的上面那篇文章，与操作习惯不符，别扭。 我猜这是从时间角度设计的，&gt; 英语叫 next，而 next 是更新的。不过别扭就改成习惯的好了，从空间位置角度设计。 方法就是修改文件： 123456789101112131415161718192021222324252627文件位置：~/blog/themes/next/layout/_macro/post.swig&#123;% if not is_index and (post.prev or post.next) %&#125; &lt;div class=&quot;post-nav&quot;&gt; &lt;div class=&quot;post-nav-next post-nav-item&quot;&gt;- &#123;% if post.next %&#125;+ &#123;% if post.prev %&#125;- &lt;a href=&quot;&#123;&#123; url_for(post.next.path) &#125;&#125;&quot; rel=&quot;next&quot; title=&quot;&#123;&#123; post.next.title &#125;&#125;&quot;&gt;+ &lt;a href=&quot;&#123;&#123; url_for(post.prev.path) &#125;&#125;&quot; rel=&quot;prev&quot; title=&quot;&#123;&#123; post.prev.title &#125;&#125;&quot;&gt;- &lt;i class=&quot;fa fa-chevron-left&quot;&gt;&lt;/i&gt; &#123;&#123; post.next.title &#125;&#125;+ &lt;i class=&quot;fa fa-chevron-left&quot;&gt;&lt;/i&gt; &#123;&#123; post.prev.title &#125;&#125; &lt;/a&gt; &#123;% endif %&#125; &lt;/div&gt; &lt;span class=&quot;post-nav-divider&quot;&gt;&lt;/span&gt; &lt;div class=&quot;post-nav-prev post-nav-item&quot;&gt;- &#123;% if post.prev %&#125;+ &#123;% if post.next %&#125;- &lt;a href=&quot;&#123;&#123; url_for(post.prev.path) &#125;&#125;&quot; rel=&quot;prev&quot; title=&quot;&#123;&#123; post.prev.title &#125;&#125;&quot;&gt;+ &lt;a href=&quot;&#123;&#123; url_for(post.next.path) &#125;&#125;&quot; rel=&quot;next&quot; title=&quot;&#123;&#123; post.next.title &#125;&#125;&quot;&gt;- &#123;&#123; post.prev.title &#125;&#125; &lt;i class=&quot;fa fa-chevron-right&quot;&gt;&lt;/i&gt;+ &#123;&#123; post.next.title &#125;&#125; &lt;i class=&quot;fa fa-chevron-right&quot;&gt;&lt;/i&gt; &lt;/a&gt; &#123;% endif %&#125; &lt;/div&gt; &lt;/div&gt;&#123;% endif %&#125; 自己改单词请注意：是 prev 不是 perv，之前自己搞错了，然后盯着电脑屏幕尴尬半天，不停想特么老子哪里错了，怎么特么就是达不到效果！？？？ 移动端显示 back-to-top 按钮和侧栏今天更新一下 NexT 主题，发现已经添加这功能，前提是主题的设计模版是 Muse 或 Mist，然后可以直接在主题配置文件中配置： 12文件位置：~/blog/themes/next/_config.yml# Enable sidebar on narrow viewonmobile: true 如果你发现你的主题配置文件_config.yml中没有这段内容，可以尝试按下面的方法更新主题。 [原方法] 个人感觉在移动端显示侧栏，有利于阅读，我的博客已经改了，你可以将浏览器窗口宽度缩小试试。还好 Google 到了一篇大佬的博客，想改的点击查看吧。 提示：最好还是更新主题，因为这样在移动端点击侧栏之外，侧栏会自动弹回，而按照上面的链接中的文章更改则无法实现。 时间轴页面的年份分隔在 Archives（归档）页面，文章之间有年份分隔，而某一个 category 和 tag 的时间轴页面却没有。怎么办呢？修改两个文件，加代码即可～ category 加到哪？要加两个位置： 12345678910文件位置：~/blog/themes/next/layout/category.swig &#123;% for post in page.posts %&#125; 位置A &#123;&#123; post_template.render(post) &#125;&#125; &#123;% endfor %&#125;...（省略好多行）..位置B（没错最后面） 加什么？绿色的自己看着加： 12345678910111213141516171819202122232425262728文件位置：~/blog/themes/next/layout/category.swig我不要 + 号！ &#123;% for post in page.posts %&#125;++ &#123;# Show year #&#125;+ &#123;% set year %&#125;+ &#123;% set post.year = date(post.date, &apos;YYYY&apos;) %&#125;++ &#123;% if post.year !== year %&#125;+ &#123;% set year = post.year %&#125;+ &lt;div class=&quot;collection-title&quot;&gt;+ &lt;h2 class=&quot;archive-year motion-element&quot; id=&quot;archive-year-&#123;&#123; year &#125;&#125;&quot;&gt;&#123;&#123; year &#125;&#125;&lt;/h2&gt;+ &lt;/div&gt;+ &#123;% endif %&#125;+ &#123;# endshow #&#125;+ &#123;&#123; post_template.render(post) &#125;&#125; &#123;% endfor %&#125;...（省略好多行）..+&#123;% block script_extra %&#125;+ &#123;% if theme.use_motion %&#125;+ &lt;script type=&quot;text/javascript&quot; id=&quot;motion.page.archive&quot;&gt;+ $(&apos;.archive-year&apos;).velocity(&apos;transition.slideLeftIn&apos;);+ &lt;/script&gt;+ &#123;% endif %&#125;+&#123;% endblock %&#125; tag 文件位置：~/blog/themes/next/layout/tag.swig，其它与的 category 修改完全一样。 说明 两段代码直接 Copy 同目录下的 archive.swig 文件里面的，而且 tag.swig 和 category.swig 好像都预留了位置似的，代码小白的我折腾了半天，才改好，不知道写代码的大佬怎么想的w(ﾟДﾟ)w～ 文章底部加上评分小星星 淘宝买东西，作为消费者的我们，看评价很重要。现在作为博主，写了一篇文章，很期待读者的反馈。而与淘宝一样，确认收货后，相比评论，更愿意五星好评。那么博客文章怎么加上呢？ 首先打开主题配置文件： 123456文件位置：~/blog/themes/next/_config.yml# Star rating support to each article.# To get your ID visit https://widgetpack.comrating: enable: true id: color: f79533 先去注释中的网站，首页点 Rating，然后注册个帐号，填一下自己博客的信息，左上角有个 ID，填进主题配置文件中就行，color改成自己喜欢的即可。另： 可以配置评分方式，侧栏 &gt; Rating &gt; Setting，建议用 IP address 或 Device(cookie)，免登录，毕竟 Socials 里面的选项几乎都被墙，不适合国内网络环境。 建议 侧栏 &gt; Site &gt; Setting 中勾选 Private 选项。 上面两步勾选后别忘了点击页面右下方的 SAVE SETTING 绿色按钮保存。 如果感觉上下留白太多，咋整？浏览器 F12 找元素，调成自己喜欢的值，然后 Copy 到custom.styl即可。 经过上面的配置，默认最下面只会显示 5 颗小星星，简洁但不明了，怎么加上文字说明呢？ 首先打开文件： 123456文件位置：~/blog/themes/next/layout/_macro/post.swig &#123;% if theme.rating.enable %&#125; &lt;div class=&quot;wp_rating&quot;&gt;+ &lt;div style=&quot;color: rgba(0, 0, 0, 0.75); font-size:13px; letter-spacing:3px&quot;&gt;(&amp;gt;看完记得五星好评哦亲&amp;lt;)&lt;/div&gt; &lt;div id=&quot;wpac-rating&quot;&gt;&lt;/div&gt; &lt;/div&gt; &#123;% endif %&#125; 然后 Ctrl + F 搜索rating，找到这段，对比我给出的，在绿色这行所示的位置，加上自己想要的说明和样式即可。 侧栏加入已运行的时间我们都有自己的生日，都知道自己的岁数，那为什么不给博客加上，让读者知道博客的年纪呢？操作很简单，而且不是精确到年而是精确到秒，233333～ 首先要加入下面代码: 1234567891011121314151617181920212223242526文件位置：~/blog/themes/next/layout/_custom/sidebar.swig&lt;div id=&quot;days&quot;&gt;&lt;/div&gt;&lt;script&gt;function show_date_time()&#123;window.setTimeout(&quot;show_date_time()&quot;, 1000);BirthDay=new Date(&quot;05/27/2017 15:13:14&quot;);today=new Date();timeold=(today.getTime()-BirthDay.getTime());sectimeold=timeold/1000secondsold=Math.floor(sectimeold);msPerDay=24*60*60*1000e_daysold=timeold/msPerDaydaysold=Math.floor(e_daysold);e_hrsold=(e_daysold-daysold)*24;hrsold=setzero(Math.floor(e_hrsold));e_minsold=(e_hrsold-hrsold)*60;minsold=setzero(Math.floor((e_hrsold-hrsold)*60));seconds=setzero(Math.floor((e_minsold-minsold)*60));document.getElementById(&apos;days&apos;).innerHTML=&quot;已运行&quot;+daysold+&quot;天&quot;+hrsold+&quot;小时&quot;+minsold+&quot;分&quot;+seconds+&quot;秒&quot;;&#125;function setzero(i)&#123;if (i&lt;10)&#123;i=&quot;0&quot; + i&#125;;return i;&#125;show_date_time();&lt;/script&gt; 上面Date的值记得改为你自己的，且按上面格式，然后修改： 1234567891011121314151617181920文件位置：~/blog/themes/next/layout/_macro/sidebar.swig &#123;# Blogroll #&#125; &#123;% if theme.links %&#125; &lt;div class=&quot;links-of-blogroll motion-element &#123;&#123; &quot;links-of-blogroll-&quot; + theme.links_layout | default(&apos;inline&apos;) &#125;&#125;&quot;&gt; &lt;div class=&quot;links-of-blogroll-title&quot;&gt; &lt;i class=&quot;fa fa-fw fa-&#123;&#123; theme.links_icon | default(&apos;globe&apos;) | lower &#125;&#125;&quot;&gt;&lt;/i&gt; &#123;&#123; theme.links_title &#125;&#125;&amp;nbsp; &lt;i class=&quot;fa fa-fw fa-&#123;&#123; theme.links_icon | default(&apos;globe&apos;) | lower &#125;&#125;&quot;&gt;&lt;/i&gt; &lt;/div&gt; &lt;ul class=&quot;links-of-blogroll-list&quot;&gt; &#123;% for name, link in theme.links %&#125; &lt;li class=&quot;links-of-blogroll-item&quot;&gt; &lt;a href=&quot;&#123;&#123; link &#125;&#125;&quot; title=&quot;&#123;&#123; name &#125;&#125;&quot; target=&quot;_blank&quot;&gt;&#123;&#123; name &#125;&#125;&lt;/a&gt; &lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt;+ &#123;% include &apos;../_custom/sidebar.swig&apos; %&#125; &lt;/div&gt; &#123;% endif %&#125;- &#123;% include &apos;../_custom/sidebar.swig&apos; %&#125; 这样就可以了！当然，要是不喜欢颜色，感觉不好看，就可以在上文所提的custom.styl加入： 1234567文件位置：~/blog/themes/next/source/css/_custom/custom.styl// 自定义的侧栏时间样式#days &#123; display: block; color: rgb(7, 179, 155); font-size: 13px; margin-top: 15px;&#125; 里面的值 F12 调成自己喜欢的，然后更改即可。要是不想放在侧栏，想放在页脚，自己应该能折腾了吧～ 添加 TopX 页面博客已有的分类，如 categories 和 tags，都是基于博主的，那么有没有一种分类是基于读者的呢？有，一种是搜索，另一种就是这里的文章阅读量排行榜。 前提是在主题配置文件中配置了 leancloud_visitors。 首先新建页面： 1所在目录：~/blog/hexo new page &quot;top&quot; 然后在主题配置文件中加上菜单 top 和它的 icon： 12文件位置：~/blog/themes/next/_config.ymlmenu: top: /top/ || signal 接着在语言翻译文件中加上菜单 top： 注意：如果你的站点配置文件中的 languages 写的不是 zh-Hans，那么这里请更改相应语言配置文件。 1234567891011文件位置：~/blog/themes/next/languages/zh_Hans.ymlmenu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 schedule: 日程表 sitemap: 站点地图 commonweal: 公益404 top: TopX /* 可以不为 TopX，随便取 */ 最后，编辑第一步新建页面生成的文件：[3] 1234567891011121314151617181920212223242526272829303132文件位置：~/blog/source/top/index.md---title: TopX /* 可以不为 TopX，随便取 */comments: falsekeywords: top,文章阅读量排行榜description: 博客文章阅读量排行榜---&lt;div id=&quot;top&quot;&gt;&lt;/div&gt;&lt;script src=&quot;//cdn1.lncld.net/static/js/3.0.4/av-min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;AV.initialize(&quot;app_id&quot;, &quot;app_key&quot;);&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var time=0 var title=&quot;&quot; var url=&quot;&quot; var query = new AV.Query(&apos;Counter&apos;); query.notEqualTo(&apos;id&apos;,0); query.descending(&apos;time&apos;); query.limit(1000); query.find().then(function (todo) &#123; for (var i=0;i&lt;1000;i++)&#123; var result=todo[i].attributes; time=result.time; title=result.title; url=result.url; var content=&quot;&lt;a href=&apos;&quot;+&quot;https://reuixiy.github.io&quot;+url+&quot;&apos;&gt;&quot;+title+&quot;&lt;/a&gt;&quot;+&quot;&lt;br /&gt;&quot;+&quot;&lt;font color=&apos;#555&apos;&gt;&quot;+&quot;阅读次数：&quot;+time+&quot;&lt;/font&gt;&quot;+&quot;&lt;br /&gt;&lt;br /&gt;&quot;; document.getElementById(&quot;top&quot;).innerHTML+=content &#125; &#125;, function (error) &#123; console.log(&quot;error&quot;); &#125;);&lt;/script&gt;&lt;style&gt;.post-description &#123; display: none; &#125;&lt;/style&gt; 必须将里面的里面的app_id和app_key替换为你的主题配置文件中的值，必须替换里面博客的链接，1000是显示文章的数量，其它可以自己看情况更改。 最后，修改样式可以在custom.styl中加入自定义代码。 Okay! 完成了！ 利用 gulp 压缩代码右键查看网页源代码发现有大量留白，咋整？利用 gulp。 首先任意目录全局安装： 1npm install gulp -g 然后到站点文件夹根目录： 1所在目录：~/blog/npm install gulp gulp-minify-css gulp-htmlmin gulp-htmlclean --save 接着在站点文件夹根目录新建 gulpfile.js： 123456789101112131415161718192021文件位置：~/blog/gulpfile.jsvar gulp = require(&apos;gulp&apos;);var minifycss = require(&apos;gulp-minify-css&apos;);var htmlmin = require(&apos;gulp-htmlmin&apos;);var htmlclean = require(&apos;gulp-htmlclean&apos;);gulp.task(&apos;minify-css&apos;, function() &#123; return gulp.src(&apos;./public/**/*.css&apos;) .pipe(minifycss()) .pipe(gulp.dest(&apos;./public&apos;))&#125;);gulp.task(&apos;minify-html&apos;, function() &#123; return gulp.src(&apos;./public/**/*.html&apos;) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true &#125;)) .pipe(gulp.dest(&apos;./public&apos;))&#125;);gulp.task(&apos;default&apos;, [&apos;minify-html&apos;, &apos;minify-css&apos;]); 最后部署到 GitHub Pages 上查看效果： 1所在目录：~/blog/hexo clean &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo d 我没有压缩 JavaScript，因为我发现会报错，实际也并不需要，因为大部分 JavaScript 都已压缩过。 这里的这段代码执行 gulp 后不支持 hexo s 本地调试，记得在哪看过解决方法，需要的自己 Google。 另外，可能会产生一些奇怪的 bugs，没看到最好，要是看到了的话就自己解决吧～[逃……] 让页脚的心跳动起来世界上有一种伟大的力量，它的名字无人不晓，就是……爱～ 更新 NexT 主题后，发现默认的icon变成了（user），不过这可阻挡不了爱的力量！ 首先编辑主题配置文件： 123文件位置：~/blog/themes/next/_config.ymlfooter:- icon: user+ icon: heart 然后编辑： 12文件位置：~/blog/themes/next/layout/_partials/footer.swig- &lt;span class=&quot;with-love&quot;&gt;+ &lt;span class=&quot;with-love&quot; id=&quot;heart&quot;&gt; 接着编辑custom.styl，加入： 12345678910111213文件位置：~/blog/themes/next/source/css/_custom/custom.styl// 自定义页脚跳动的心样式@keyframes heartAnimate &#123; 0%,100%&#123;transform:scale(1);&#125; 10%,30%&#123;transform:scale(0.9);&#125; 20%,40%,60%,80%&#123;transform:scale(1.1);&#125; 50%,70%&#123;transform:scale(1.1);&#125;&#125;#heart &#123; animation: heartAnimate 1.33s ease-in-out infinite;&#125;.with-love &#123; color: rgb(255, 113, 168);&#125; 页脚加上微信二维码主题默认的微信订阅个人感觉不美观，看到很多网站都是在页脚有个微信的 Logo，然后鼠标移动到上面便会显示二维码，这样感觉很棒。 首先编辑文件，在文件最后加上下面代码： 1234567文件位置：~/blog/themes/next/layout/_partials/footer.swig&lt;div class=&quot;weixin-box&quot;&gt; &lt;div class=&quot;weixin-menu&quot;&gt; &lt;div class=&quot;weixin-hover&quot;&gt; &lt;div class=&quot;weixin-description&quot;&gt;微信扫一扫，订阅本博客&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 然后编辑custom.styl，加入： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051文件位置：~/blog/themes/next/source/css/_custom/custom.styl// 自定义的页脚微信订阅号样式.weixin-box &#123; position: absolute; bottom: 43px; left: 10px; border-radius: 5px; box-shadow: 0px 0px 10px 0px rgba(0, 0, 0, 0.35);&#125;.weixin-menu &#123; position: relative; height: 24px; width: 24px; cursor: pointer; background: url(https://微信的logo.svg); background-size: 24px 24px;&#125;.weixin-hover &#123; position: absolute; bottom: 0px; left: 0px; height: 0px; width: 0px; border-radius: 3px; box-shadow: 0px 0px 10px 0px rgba(0, 0, 0, 0.35); background: url(https://二维码.svg); background-color: #fff; background-repeat: no-repeat; background-size: 150px 150px; transition: all 0.35s ease-in-out; z-index: 1024; opacity: 0;&#125;.weixin-menu:hover .weixin-hover &#123; bottom: 24px; left: 24px; height: 170px; width: 150px; opacity: 1;&#125;.weixin-description &#123; opacity: 0; position: absolute; bottom: 3%; left: 5%; right: 5%; font-size: 12px; transition: all 0.35s cubic-bezier(1, 0, 0, 1);&#125;.weixin-menu:hover .weixin-description &#123; opacity: 1;&#125; 图片务必用矢量图 svg 格式，否则手机上显示效果很差，其它的自己看情况更改。 更改标签云（tagcloud）的颜色如果你和我一样个性化了博客的整体布局颜色，那么默认的标签云页面可能看起来很丑，怎么更改？ 修改下文件： 1文件位置：~/blog/themes/next/layout/page.swig&#123;&#123; tagcloud(&#123;min_font: 13, max_font: 31, amount: 1000, color: true, start_color: &apos;#9733EE&apos;, end_color: &apos;#FF512F&apos;&#125;) &#125;&#125; 修改对应参数值即可，参数说明见 Hexo 官方文档，颜色可以参考这个网站，自己去纠结…… 点击侧栏头像回到博客首页不知道为什么，我看到侧栏头像的第一反应是点击，然后心理预期会跳到博客首页，可惜也仅是预期，那么开始动手吧～ 首先要在主题配置文件中配置好，比如我把头像avatar.gif放在~/blog/source/uploads/下，则： 12345文件位置：~/blog/themes/next/_config.yml# Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gif-#avatar: /images/avatar.gif+avatar: /uploads/avatar.gif 然后编辑文件： 12345文件位置：~/blog/themes/next/layout/_macro/sidebar.swig+ &lt;a href=&quot;/&quot;&gt; &lt;img class=&quot;site-author-image&quot; itemprop=&quot;image&quot; src=&quot;&#123;&#123; url_for( theme.avatar | default(theme.images + &apos;/avatar.gif&apos;) ) &#125;&#125;&quot; alt=&quot;&#123;&#123; theme.author &#125;&#125;&quot; /&gt;+ &lt;/a&gt; 最后就 OK 了～ 文章摘要图片俗话说：“图文并茂”，现实中用笔书写文章实现起来比较困难，但在博客上可以很轻松实现. 首先，文章摘要（excerpt）是指每篇文章在页面（page）上显示的那部分内容，也就是 [Read More] 之前的文章内容。由于它会展示在页面，因此在每篇文章的文章摘要中加一张图片，页面看起来就很美观。 但是有时候可能会出现一个问题：你想从文章中选一张图片作为文章摘要图片，而这张图片由于写作要求，必须添加在文章的末尾，这样点 [Read More] 查看文章时，这张图片就会重复出现了。咋办？ 前提是在主题配置文件中： 1234文件位置：~/blog/themes/next/_config.ymlexcerpt_description: falseauto_excerpt: enable: false 首先加代码： 1234567891011121314151617181920212223242526文件位置：~/blog/themes/next/layout/_macro/post.swig &#123;% if is_index %&#125; &#123;% if post.description and theme.excerpt_description %&#125; &#123;&#123; post.description &#125;&#125; &lt;!--noindex--&gt; &lt;div class=&quot;post-button text-center&quot;&gt; &lt;a class=&quot;btn&quot; href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot;&gt; &#123;&#123; __(&apos;post.read_more&apos;) &#125;&#125; &amp;raquo; &lt;/a&gt; &lt;/div&gt; &lt;!--/noindex--&gt; &#123;% elif post.excerpt %&#125; &#123;&#123; post.excerpt &#125;&#125;+ + &#123;% if post.image %&#125;+ &lt;div class=&quot;out-img-topic&quot;&gt;+ &lt;img src=&#123;&#123; post.image &#125;&#125; class=&quot;img-topic&quot; /&gt;+ &lt;/div&gt;+ &#123;% endif %&#125;+ &lt;!--noindex--&gt; &lt;div class=&quot;post-button text-center&quot;&gt; &lt;a class=&quot;btn&quot; href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&#123;% if theme.scroll_to_more %&#125;#&#123;&#123; __(&apos;post.more&apos;) &#125;&#125;&#123;% endif %&#125;&quot; rel=&quot;contents&quot;&gt; &#123;&#123; __(&apos;post.read_more&apos;) &#125;&#125; &amp;raquo; &lt;/a&gt; &lt;/div&gt; &lt;!--/noindex--&gt; 为了防止有的图片宽度不够导致风格不够统一，页面不美观，需要在custom.styl中加入： 1234文件位置：~/blog/themes/next/source/css/_custom/custom.styl// 自定义的文章摘要图片样式img.img-topic &#123; width: 100%;&#125; 最后编辑有这需求的相关文章时，在Front-matter（文件最上方以---分隔的区域）加上一行： 1image: url url即图片的链接地址～ 文章置顶由于博客的首页可能是被浏览最多的页面，所以首页的前几篇文章被阅读的可能性比较大。可以利用这个特点，通过将自己认为重要的文章放在首页，从而让重要的文章被阅读的可能性增大。 但是，默认的排序只有一个维度——时间，两种选择——正序和倒序，这就造成自己的得意之作被“埋没”了，怎么办呢，如何实现文章的置顶？ NexT 主题以前有过这个功能，然而由于一些bugs（issue）被去掉了。不过在这个丰富的 issue 中，我自己摸索出了一种解决方法，参考了 issue 中的那篇文章。 首先移除默认安装的插件： 1所在目录：~/blog/npm uninstall hexo-generator-index --save 然后安装新插件： 1所在目录：~/blog/npm install hexo-generator-index-pin-top --save 最后编辑有这需求的相关文章时，在Front-matter（文件最上方以---分隔的区域）加上一行： 1top: true 然后就行了，如果你置顶了多篇，怎么控制顺序呢？设置top的值（大的在前面），比如： 1234567# Post a.mdtitle: atop: 1# Post b.mdtitle: btop: 10 那么文章 b 便会显示在文章 a 的前面。 可是，没有任何标记啊，读者怎么知道文章置顶了～ 还好 NexT 原有的置顶功能有考虑到这个，且置顶的样式没有被移除，所以可以直接利用，编辑文件： 12345678910111213141516171819202122232425262728文件位置：~/blog/node_modules/hexo-generator-index-pin-top/lib/generator.js&apos;use strict&apos;;var pagination = require(&apos;hexo-pagination&apos;);module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.sticky &amp;&amp; b.sticky) &#123; // 两篇文章sticky都有定义 if(a.sticky == b.sticky) return b.date - a.date; // 若sticky值一样则按照文章日期降序排 else return b.sticky - a.sticky; // 否则按照sticky值降序排 &#125; else if(a.sticky &amp;&amp; !b.sticky) &#123; // 以下是只有一篇文章sticky有定义，那么将有sticky的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.sticky &amp;&amp; b.sticky) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, &#123; perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: &#123; __index: true &#125; &#125;);&#125;; 也就是将插件的top全部替换为 NexT 原有的sticky，然后将Front-matter中的top替换为sticky，就能调用 NexT 主题原有的置顶样式了。 最后可以自定义一下样式： 12345678910111213文件位置：~/blog/themes/next/source/css/_custom/custom.styl// 自定义的文章置顶样式.post-sticky-flag &#123; font-size: inherit; float: left; color: rgb(0, 0, 0); cursor: help; transition-duration: 0.2s; transition-timing-function: ease-in-out; transition-delay: 0s;&#125;.post-sticky-flag:hover &#123; color: #07b39b;&#125; 已发现的 bug：新安装的插件无法实现站点配置文件中order_by: date，即文章按时间从旧到新排列的配置，也就意味着文章只能按默认的时间从新到旧排列。 背景图片通过 jquery-backstretch，具体操作呢，编辑文件： 12345文件位置：~/blog/themes/next/layout/_layout.swig+ &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js&quot;&gt;&lt;/script&gt;;+ &lt;script&gt;+ $(&quot;body&quot;).backstretch(&quot;https://背景图.jpg&quot;);+ &lt;/script&gt;&lt;/body&gt; 加入到文件最后面&lt;/body&gt;前面即可。 你可以浏览器按 F12 查看我的页面，就可以在&lt;/body&gt;前发现。 幻灯片等更多用法请自行查看 GitHub 上的 README。 动态效果可以在主题配置文件_config.yml里的motion中配置，但是如果你和我一样更改了博客的背景色，可能不能达到很好的效果，怎么办呢？参考这里，修改下面两个文件的相应内容。 ~/blog/themes/next/source/css/_common/components/post/post.styl ~/blog/themes/next/source/js/src/motion.js]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot.JavaMail]]></title>
    <url>%2F2018%2F12%2F01%2FSpringBoot-JavaMail%2F</url>
    <content type="text"><![CDATA[JavaMail是SUN提供给广大Java开发人员的一款邮件发送和接受的一款开源类库，支持常用的邮件协议，如：SMTP、POP3、IMAP，开发人员使用JavaMail编写邮件程序时，不再需要考虑底层的通讯细节如：Socket而是关注在逻辑层面。JavaMail可以发送各种复杂MIME格式的邮件内容，注意JavaMail仅支持JDK4及以上版本。虽然JavaMail是JDK的API但它并没有直接加入JDK中，所以我们需要另外添加依赖。 本章目标将Java提供的JavaMail类库与SpringBoot项目进行整合，并且简单封装下JavaMail类库。 构建项目本章项目无关Web相关内容，所以创建项目时选择Jar形式创建，并且不需要预先导入依赖，项目初始化多余的依赖并没有添加，如果你选择的是War项目也没有关系，那好，我们接下来把我们的主角JavaMail请出来吧，把对应的依赖添加到pom.xml配置文件内。如下所示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-example&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;spring-boot-example&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;--JavaMail--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.mail&lt;/groupId&gt; &lt;artifactId&gt;mail&lt;/artifactId&gt; &lt;version&gt;1.4.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 依赖我们已经导入成功了，接下来我们开始编写JavaMail的封装，我这里简单的对JavaMail做出封装，如果您需要更完美的封装，请对我的代码做出修改即可，先来编写一个MailEntity类来保存发送邮件时需要的参数字段，如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import java.io.Serializable;import java.util.ArrayList;import java.util.List;public class MailEntity implements Serializable &#123; //此处填写SMTP服务器 private String smtpService; //设置端口号 private String smtpPort; //设置发送邮箱地址 private String fromMailAddress; //设置发送邮箱SMTP口令 private String fromMailStmpPwd; //设置邮件标题 private String title; //设置邮件内容 private String content; //内容格式（默认采用html） private String contentType; //接收邮件地址集合 private List&lt;String&gt; list = new ArrayList&lt;&gt;(); public String getSmtpService() &#123; return smtpService; &#125; public void setSmtpService(String smtpService) &#123; this.smtpService = smtpService; &#125; public String getSmtpPort() &#123; return smtpPort; &#125; public void setSmtpPort(String smtpPort) &#123; this.smtpPort = smtpPort; &#125; public String getFromMailAddress() &#123; return fromMailAddress; &#125; public void setFromMailAddress(String fromMailAddress) &#123; this.fromMailAddress = fromMailAddress; &#125; public String getFromMailStmpPwd() &#123; return fromMailStmpPwd; &#125; public void setFromMailStmpPwd(String fromMailStmpPwd) &#123; this.fromMailStmpPwd = fromMailStmpPwd; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125; public String getContentType() &#123; return contentType; &#125; public void setContentType(String contentType) &#123; this.contentType = contentType; &#125; public List&lt;String&gt; getList() &#123; return list; &#125; public void setList(List&lt;String&gt; list) &#123; this.list = list; &#125;&#125; 我们的MailEntity包含了上图3的字段内容，都是一些必填选项，下面我们来创建一个MailSender也就是邮件发送者实体，主要作用就是用来配置发送邮件参数以及执行发送邮件，代码如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121import com.example.springbootexample.Mail.Until.PropertiesUtil;import javax.mail.*;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeMessage;import javax.mail.internet.MimeUtility;import java.util.List;import java.util.Properties;import com.sun.mail.util.MailSSLSocketFactory;public class MailSender &#123; //邮件实体 private static MailEntity mail = new MailEntity(); //设置邮件标题 public MailSender title(String title) &#123; mail.setTitle(title); return this; &#125; //设置邮件内容 public MailSender content(String content) &#123; mail.setContent(content); return this; &#125; //设置邮件格式 public MailSender cpntentType(MailContentEnum typeEnum) &#123; mail.setContentType(typeEnum.getValue()); return this; &#125; //设置请求邮件地址 public MailSender targets(List&lt;String&gt; targets) &#123; mail.setList(targets); return this; &#125; //执行发送邮件 public void send() throws Exception &#123; //默认使用html发送 if (mail.getContentType() == null) &#123; mail.setContentType(MailContentEnum.HTML.getValue()); &#125; if (mail.getTitle() == null || mail.getTitle().trim().length() == 0) &#123; throw new Exception("邮件标题没有设置，请设置有邮件标题"); &#125; if (mail.getContent() == null || mail.getContent().trim().length() == 0) &#123; throw new Exception("邮件内容没有设置，请设置邮件内容"); &#125; if (mail.getList().size() == 0) &#123; throw new Exception("没有接收者邮箱地址"); &#125; //读取/resource/mall_zh_CN.properties中的内容 final PropertiesUtil properties = new PropertiesUtil("mail"); //创建Properties类用于记录邮箱的一些属性 final Properties props = new Properties(); // 关于QQ邮箱，还要设置SSL加密，加上以下代码即可 MailSSLSocketFactory sf = new MailSSLSocketFactory(); sf.setTrustAllHosts(true); props.put("mail.smtp.ssl.enable", "true"); props.put("mail.smtp.ssl.socketFactory", sf); //表示SMTP发送邮件，必须进行身份验证 props.put("mail.smtp.auth", "true"); //此处填写smtp服务器 props.put("mail.smtp.host", properties.getValue("mail.smtp.service")); //设置端口。QQ邮箱给出的俩个端口465//587 props.put("mail.smtp.port", properties.getValue("mail.smtp.port")); //设置发送邮箱 props.put("mail.user", properties.getValue("mail.from.address")); //设置发送邮箱的16位SMTP口令 props.put("mail.password", properties.getValue("mail.from.smtp.pwd")); //构建授权信息，用于进行SMTP省份验证 Authenticator authenticator = new Authenticator() &#123; @Override protected PasswordAuthentication getPasswordAuthentication() &#123; //用户名，密码 String userName = props.getProperty("mail.user"); String passWord = props.getProperty("mail.password"); return new PasswordAuthentication(userName, passWord); &#125; &#125;; //使用环境属性和授权信息，创建邮件会话 Session mailSession = Session.getInstance(props, authenticator); mailSession.setDebug(true); //创建邮件消息 MimeMessage message = new MimeMessage(mailSession); //设置发件人 String nickName = MimeUtility.encodeText(properties.getValue("mail.from.nickname")); InternetAddress form = new InternetAddress(nickName + "&lt;" + props.getProperty("mail.user") + "&gt;"); message.setFrom(form); //设置邮件标题 message.setSubject(mail.getTitle()); //html发送邮件 if (mail.getContentType().equals(MailContentEnum.HTML.getValue())) &#123; //设置邮件标题 message.setContent(mail.getContent(), mail.getContentType()); &#125; //文本发送邮件 else if (mail.getContentType().equals(MailContentEnum.TEXT.getValue())) &#123; message.setText(mail.getContent()); &#125; //发送邮箱地址 List&lt;String&gt; targets = mail.getList(); for (int i = 0; i &lt; targets.size(); i++) &#123; try &#123; //设置收件人的邮箱 InternetAddress to = new InternetAddress(targets.get(i)); message.setRecipients(Message.RecipientType.TO, new InternetAddress[]&#123;to&#125;); //发送邮件 Transport.send(message); &#125; catch (Exception e) &#123; continue; &#125; &#125; &#125;&#125; 因为简书的富文本编辑器不支持代码块，下次编写文章使用MarkDown方式来写，类过长贴起来图挺费劲。上面可以看到我使用到了MailContentTypeEnum以及PropertiesUtil工具类。 MailContentTypeEnum这是一个我自定义的枚举类型，枚举类型包含了邮件内容的类型，目前我仅仅添加了两种，一种是html另外一种则是text形式，具体代码如下所示： 123456789101112131415public enumMailContentEnum &#123; TEXT("text"), HTML("text/html;charset=UTF-8"); private String value; MailContentEnum(String value) &#123; this.value = value; &#125; public String getValue() &#123; return value; &#125;&#125; PropertiesUtilPropertiesUtil是用于读取*.properties配置文件的工具类，使用JavaMail需要配置SMTP以及用户名、密码等也就是MailEntity内的字段，那么我们在/resource目录下创建一个名字叫mail.properties的配置文件，里面存放我们定义的邮件发送参数配置，这样方便修改，我分别贴出PropertiesUtil、mail.properties代码内容，如下所示： 123456789101112131415161718192021import java.util.Locale;import java.util.ResourceBundle;public class PropertiesUtil &#123; private ResourceBundle resource = null; private final String fileName; //获取文件资源对象 public PropertiesUtil(String fileName) &#123; this.fileName = fileName; Locale locale = new Locale("zh", "CN"); this.resource = ResourceBundle.getBundle(this.fileName, locale); &#125; //key value public String getValue(String key) &#123; String message = this.resource.getString(key); return message; &#125;&#125; 12345678910#对应发送服务器的smtp服务器地址mail.smtp.service=smtp.qq.com#对应服务器的smtp服务端口号mail.smtp.port=465#发件人邮箱地址mail.from.address=809962111@qq.com#smtp授权密码mail.from.smtp.pwd= // smtp授权密码#发件人邮箱显示昵称mail.from.nickname=aaa 我使用的QQ邮箱地址作为测试，如果你需要使用你的QQ地址作为测试，请先到QQ邮箱开启POP3/SMTP服务，开启步骤如下。 开启POP3/SMTP第一步：进入邮箱点击“设置”，如下图所示： 第二部：点击“账户”。 第三步：获取授权码。 我的POP3以及SMTP以及开启了所以这里显示的状态是已开启，如果您第一次使用QQ邮箱的SMTP服务，请点击“开启”并且按照提示步骤完成获取“授权码”即可，授权码就是发送邮件参数的smtp.pwd属性。 测试发送邮件我们创建一个sendMailTo类来作为测试入口，因为我们的项目是jar形式，所以我们直接新建一个main方法直接调用发送邮件就可以了，如下所示测试代码： 123456789101112131415161718import com.example.springbootexample.Mail.Config.MailContentEnum;import com.example.springbootexample.Mail.Config.MailSender;import java.util.ArrayList;public class sendMailTo &#123; public static void main(String[] args) throws Exception &#123; new MailSender() .title("测试SpringBoot发送邮件") .content("简单文本内容发送") .cpntentType(MailContentEnum.TEXT) .targets(new ArrayList&lt;String&gt;() &#123;&#123; add("895800655@qq.com"); &#125;&#125;) .send(); &#125;&#125; 我是向我的895800655@qq.com邮箱发送了一条文本类型的测试邮件，发送效果图如下图所示：]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何通过Hexo与GitHub搭建属于自己的博客]]></title>
    <url>%2F2018%2F11%2F28%2FHexoAndGit%2F</url>
    <content type="text"><![CDATA[关于博客写博客对于程序猿来说，应该是个优秀的习惯，个人也觉得蛮高大上的 ^_^。网上的博客论坛网站也多种多样，个人觉得在长久以来的不断竞争淘汰中，各大网站的功能等可能都相差无几了，选择自己稍微偏好的就可以了。 我的个人情况就是结合Hexo和Github Pages的独立个人博客网页，因为听说拥有自己的Github主页也是一件蛮高大上的事 -_- 。 关于Hexo Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Heroku上，是搭建博客的首选框架。这里我们选用的是GitHub，你没看错，全球最大的同性恋交友网站（逃……）。Hexo同时也是GitHub上的开源项目，参见：hexojs/hexo 如果想要更加全面的了解Hexo，可以到其官网 Hexo 了解更多的细节，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。这里，默认各位猿/媛儿都知道GitHub就不再赘述。 关于Github然后简单介绍一下Github以及其Github Pages功能。GitHub是一个面向开源及私有软件项目的托管平台，也是一个分布式版本控制系统，详情见百度百科。说到分布式，自然也有另外一种集中式版本控制系统：SVN，有兴趣小伙伴可以了解百度百科。GIt是SVN的发展版，而且现在主流也是GIt，但某些大公司依然在使用SVN，二者各有优劣，自行体会，此处不做详解，用一张图简单说明： GIthub Pages则是github上的一项功能，可以放置网页文件到指定文件夹，然后给你一个专属域名用于展示一些项目，但现在大多用来开发制作个人博客网站。接下来就一步步按照我曾经的步骤来搭建个人博客，顺便讲讲沿途遇到过的坑，如没有的提及请自行百度。 搭建步骤： 搭建环境准备（包括node.js和git环境，gitHub账户的配置） 配置Hexo 配置GitHub 常用命令 搭建环境 安装git 可以到git官网下载相应平台的版本进行安装。考虑到你可能是无照驾驶，直接在github/git下载。 申请github账号 进入github注册。此处省略一千字。 安装node.js, 到node.js官网下载相应平台的最新版本，傻瓜式安装（自带安装npm）。 安装hexo 打开git bash或者cmd，执行以下命令: 1npm install -g hexo-cli ​ 如果没有错误提示，那么在git的交互环境输入以下命令查看git版本： 1hexo version 配置Hexo首先创建一个文件夹，如blog，用来存放hexo的配置文件等，然后进入blog进行操作。 初始化 右键 git bash，执行以下命令: 1hexo init 安装依赖包 1npm install 生成静态页面 1hexo generate 或者 hexo g 本地运行 1hexo server 或者 hexo s 打开浏览器，在地址栏输入localhost:4000，就可以看到我们搭建好的本地博客了。到此只是搭建好了本地博客，还需要将博客部署到github上。 配置GitHub 新建repository 建立与你用户名对应的仓库，仓库名必须为【 your_username.github.io】 。 部署博客进入你的hexo文件夹根目录下，用编辑器打开_config.yml，修改deploy项，如下（根据你的github进行相应更改）： 1234deploy: type: git #注意：有的版本type是github repo: https://github.com/你的账户名/你的账户名.github.io.git branch: master 此时就完成部署了，用浏览器访问xiaobinhong1.github.io即可(第一次发布可能会有10分钟的延迟)。每次修改完本地的文件后要执行以下命令，重新部署到github上： 123hexo clean hexo generate hexo deploy 或者 hexo d 常用命令1234567hexo new “postName” // 新建文章 hexo new page “pageName” // 新建页面 hexo generate // 生成静态页面至public目录hexo server // 开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy // 将.deploy目录部署到GitHubhexo help // 查看帮助hexo version // 查看Hexo的版本]]></content>
      <categories>
        <category>Hexo</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
