<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo进阶高级功能配置]]></title>
    <url>%2F2018%2F12%2F19%2FHexo-config%2F</url>
    <content type="text"><![CDATA[进阶高级功能配置更多如外挂一样的功能配置，就直接贴大佬的文章了，哪些功能自己喜欢，按照大佬的教程来配置就行。不过也有坑，比如有些功能（超链接样式、侧栏头像圆形并旋转）可以直接通过在custom.styl添加 CSS 代码实现，无需更改其它文件！ hexo高阶教程next主题优化 hexo的next主题个性化教程:打造炫酷网站 Hexo搭建博客的个性化设置 第一篇文章内有 NexT 主题的文件目录说明，这对自己自定义博客有很大帮助。 更改上一篇，下一篇的顺序进入一篇文章，在文章底部，有上下篇的链接（&lt; &gt;），但是点 &gt; 发现进入的是页面中的的上面那篇文章，与操作习惯不符，别扭。 我猜这是从时间角度设计的，&gt; 英语叫 next，而 next 是更新的。不过别扭就改成习惯的好了，从空间位置角度设计。 方法就是修改文件： 123456789101112131415161718192021222324252627文件位置：~/blog/themes/next/layout/_macro/post.swig&#123;% if not is_index and (post.prev or post.next) %&#125; &lt;div class="post-nav"&gt; &lt;div class="post-nav-next post-nav-item"&gt;- &#123;% if post.next %&#125;+ &#123;% if post.prev %&#125;- &lt;a href="&#123;&#123; url_for(post.next.path) &#125;&#125;" rel="next" title="&#123;&#123; post.next.title &#125;&#125;"&gt;+ &lt;a href="&#123;&#123; url_for(post.prev.path) &#125;&#125;" rel="prev" title="&#123;&#123; post.prev.title &#125;&#125;"&gt;- &lt;i class="fa fa-chevron-left"&gt;&lt;/i&gt; &#123;&#123; post.next.title &#125;&#125;+ &lt;i class="fa fa-chevron-left"&gt;&lt;/i&gt; &#123;&#123; post.prev.title &#125;&#125; &lt;/a&gt; &#123;% endif %&#125; &lt;/div&gt; &lt;span class="post-nav-divider"&gt;&lt;/span&gt; &lt;div class="post-nav-prev post-nav-item"&gt;- &#123;% if post.prev %&#125;+ &#123;% if post.next %&#125;- &lt;a href="&#123;&#123; url_for(post.prev.path) &#125;&#125;" rel="prev" title="&#123;&#123; post.prev.title &#125;&#125;"&gt;+ &lt;a href="&#123;&#123; url_for(post.next.path) &#125;&#125;" rel="next" title="&#123;&#123; post.next.title &#125;&#125;"&gt;- &#123;&#123; post.prev.title &#125;&#125; &lt;i class="fa fa-chevron-right"&gt;&lt;/i&gt;+ &#123;&#123; post.next.title &#125;&#125; &lt;i class="fa fa-chevron-right"&gt;&lt;/i&gt; &lt;/a&gt; &#123;% endif %&#125; &lt;/div&gt; &lt;/div&gt;&#123;% endif %&#125; 自己改单词请注意：是 prev 不是 perv，之前自己搞错了，然后盯着电脑屏幕尴尬半天，不停想特么老子哪里错了，怎么特么就是达不到效果！？？？ 移动端显示 back-to-top 按钮和侧栏今天更新一下 NexT 主题，发现已经添加这功能，前提是主题的设计模版是 Muse 或 Mist，然后可以直接在主题配置文件中配置： 12文件位置：~/blog/themes/next/_config.yml# Enable sidebar on narrow viewonmobile: true 如果你发现你的主题配置文件_config.yml中没有这段内容，可以尝试按下面的方法更新主题。 [原方法] 个人感觉在移动端显示侧栏，有利于阅读，我的博客已经改了，你可以将浏览器窗口宽度缩小试试。还好 Google 到了一篇大佬的博客，想改的点击查看吧。 提示：最好还是更新主题，因为这样在移动端点击侧栏之外，侧栏会自动弹回，而按照上面的链接中的文章更改则无法实现。 时间轴页面的年份分隔在 Archives（归档）页面，文章之间有年份分隔，而某一个 category 和 tag 的时间轴页面却没有。怎么办呢？修改两个文件，加代码即可～ category加到哪？要加两个位置： 12345678910文件位置：~/blog/themes/next/layout/category.swig &#123;% for post in page.posts %&#125; 位置A &#123;&#123; post_template.render(post) &#125;&#125; &#123;% endfor %&#125;...（省略好多行）..位置B（没错最后面） 加什么？绿色的自己看着加： 12345678910111213141516171819202122232425262728文件位置：~/blog/themes/next/layout/category.swig我不要 + 号！ &#123;% for post in page.posts %&#125;++ &#123;# Show year #&#125;+ &#123;% set year %&#125;+ &#123;% set post.year = date(post.date, 'YYYY') %&#125;++ &#123;% if post.year !== year %&#125;+ &#123;% set year = post.year %&#125;+ &lt;div class="collection-title"&gt;+ &lt;h2 class="archive-year motion-element" id="archive-year-&#123;&#123; year &#125;&#125;"&gt;&#123;&#123; year &#125;&#125;&lt;/h2&gt;+ &lt;/div&gt;+ &#123;% endif %&#125;+ &#123;# endshow #&#125;+ &#123;&#123; post_template.render(post) &#125;&#125; &#123;% endfor %&#125;...（省略好多行）..+&#123;% block script_extra %&#125;+ &#123;% if theme.use_motion %&#125;+ &lt;script type="text/javascript" id="motion.page.archive"&gt;+ $('.archive-year').velocity('transition.slideLeftIn');+ &lt;/script&gt;+ &#123;% endif %&#125;+&#123;% endblock %&#125; tag文件位置：~/blog/themes/next/layout/tag.swig，其它与的 category 修改完全一样。 说明两段代码直接 Copy 同目录下的 archive.swig 文件里面的，而且 tag.swig 和 category.swig 好像都预留了位置似的，代码小白的我折腾了半天，才改好，不知道写代码的大佬怎么想的w(ﾟДﾟ)w～ 文章底部加上评分小星星淘宝买东西，作为消费者的我们，看评价很重要。现在作为博主，写了一篇文章，很期待读者的反馈。而与淘宝一样，确认收货后，相比评论，更愿意五星好评。那么博客文章怎么加上呢？ 首先打开主题配置文件： 123456文件位置：~/blog/themes/next/_config.yml# Star rating support to each article.# To get your ID visit https://widgetpack.comrating: enable: true id: color: f79533 先去注释中的网站，首页点 Rating，然后注册个帐号，填一下自己博客的信息，左上角有个 ID，填进主题配置文件中就行，color改成自己喜欢的即可。另： 可以配置评分方式，侧栏 &gt; Rating &gt; Setting，建议用 IP address 或 Device(cookie)，免登录，毕竟 Socials 里面的选项几乎都被墙，不适合国内网络环境。 建议 侧栏 &gt; Site &gt; Setting 中勾选 Private 选项。 上面两步勾选后别忘了点击页面右下方的 SAVE SETTING 绿色按钮保存。 如果感觉上下留白太多，咋整？浏览器 F12 找元素，调成自己喜欢的值，然后 Copy 到custom.styl即可。 经过上面的配置，默认最下面只会显示 5 颗小星星，简洁但不明了，怎么加上文字说明呢？ 首先打开文件： 123456文件位置：~/blog/themes/next/layout/_macro/post.swig &#123;% if theme.rating.enable %&#125; &lt;div class="wp_rating"&gt;+ &lt;div style="color: rgba(0, 0, 0, 0.75); font-size:13px; letter-spacing:3px"&gt;(&amp;gt;看完记得五星好评哦亲&amp;lt;)&lt;/div&gt; &lt;div id="wpac-rating"&gt;&lt;/div&gt; &lt;/div&gt; &#123;% endif %&#125; 然后 Ctrl + F 搜索rating，找到这段，对比我给出的，在绿色这行所示的位置，加上自己想要的说明和样式即可。 侧栏加入已运行的时间我们都有自己的生日，都知道自己的岁数，那为什么不给博客加上，让读者知道博客的年纪呢？操作很简单，而且不是精确到年而是精确到秒，233333～ 首先要加入下面代码: 1234567891011121314151617181920212223242526文件位置：~/blog/themes/next/layout/_custom/sidebar.swig&lt;div id="days"&gt;&lt;/div&gt;&lt;script&gt;function show_date_time()&#123;window.setTimeout("show_date_time()", 1000);BirthDay=new Date("05/27/2017 15:13:14");today=new Date();timeold=(today.getTime()-BirthDay.getTime());sectimeold=timeold/1000secondsold=Math.floor(sectimeold);msPerDay=24*60*60*1000e_daysold=timeold/msPerDaydaysold=Math.floor(e_daysold);e_hrsold=(e_daysold-daysold)*24;hrsold=setzero(Math.floor(e_hrsold));e_minsold=(e_hrsold-hrsold)*60;minsold=setzero(Math.floor((e_hrsold-hrsold)*60));seconds=setzero(Math.floor((e_minsold-minsold)*60));document.getElementById('days').innerHTML="已运行"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒";&#125;function setzero(i)&#123;if (i&lt;10)&#123;i="0" + i&#125;;return i;&#125;show_date_time();&lt;/script&gt; 上面Date的值记得改为你自己的，且按上面格式，然后修改： 1234567891011121314151617181920文件位置：~/blog/themes/next/layout/_macro/sidebar.swig &#123;# Blogroll #&#125; &#123;% if theme.links %&#125; &lt;div class="links-of-blogroll motion-element &#123;&#123; "links-of-blogroll-" + theme.links_layout | default('inline') &#125;&#125;"&gt; &lt;div class="links-of-blogroll-title"&gt; &lt;i class="fa fa-fw fa-&#123;&#123; theme.links_icon | default('globe') | lower &#125;&#125;"&gt;&lt;/i&gt; &#123;&#123; theme.links_title &#125;&#125;&amp;nbsp; &lt;i class="fa fa-fw fa-&#123;&#123; theme.links_icon | default('globe') | lower &#125;&#125;"&gt;&lt;/i&gt; &lt;/div&gt; &lt;ul class="links-of-blogroll-list"&gt; &#123;% for name, link in theme.links %&#125; &lt;li class="links-of-blogroll-item"&gt; &lt;a href="&#123;&#123; link &#125;&#125;" title="&#123;&#123; name &#125;&#125;" target="_blank"&gt;&#123;&#123; name &#125;&#125;&lt;/a&gt; &lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt;+ &#123;% include '../_custom/sidebar.swig' %&#125; &lt;/div&gt; &#123;% endif %&#125;- &#123;% include '../_custom/sidebar.swig' %&#125; 这样就可以了！当然，要是不喜欢颜色，感觉不好看，就可以在上文所提的custom.styl加入： 1234567文件位置：~/blog/themes/next/source/css/_custom/custom.styl// 自定义的侧栏时间样式#days &#123; display: block; color: rgb(7, 179, 155); font-size: 13px; margin-top: 15px;&#125; 里面的值 F12 调成自己喜欢的，然后更改即可。要是不想放在侧栏，想放在页脚，自己应该能折腾了吧～ 添加 TopX 页面博客已有的分类，如 categories 和 tags，都是基于博主的，那么有没有一种分类是基于读者的呢？有，一种是搜索，另一种就是这里的文章阅读量排行榜。 前提是在主题配置文件中配置了 leancloud_visitors。 首先新建页面： 1所在目录：~/blog/hexo new page "top" 然后在主题配置文件中加上菜单 top 和它的 icon： 12文件位置：~/blog/themes/next/_config.ymlmenu: top: /top/ || signal 接着在语言翻译文件中加上菜单 top： 注意：如果你的站点配置文件中的 languages 写的不是 zh-Hans，那么这里请更改相应语言配置文件。 1234567891011文件位置：~/blog/themes/next/languages/zh_Hans.ymlmenu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 schedule: 日程表 sitemap: 站点地图 commonweal: 公益404 top: TopX /* 可以不为 TopX，随便取 */ 最后，编辑第一步新建页面生成的文件：[3] 1234567891011121314151617181920212223242526272829303132文件位置：~/blog/source/top/index.md---title: TopX /* 可以不为 TopX，随便取 */comments: falsekeywords: top,文章阅读量排行榜description: 博客文章阅读量排行榜---&lt;div id="top"&gt;&lt;/div&gt;&lt;script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"&gt;&lt;/script&gt;&lt;script&gt;AV.initialize("app_id", "app_key");&lt;/script&gt;&lt;script type="text/javascript"&gt; var time=0 var title="" var url="" var query = new AV.Query('Counter'); query.notEqualTo('id',0); query.descending('time'); query.limit(1000); query.find().then(function (todo) &#123; for (var i=0;i&lt;1000;i++)&#123; var result=todo[i].attributes; time=result.time; title=result.title; url=result.url; var content="&lt;a href='"+"https://reuixiy.github.io"+url+"'&gt;"+title+"&lt;/a&gt;"+"&lt;br /&gt;"+"&lt;font color='#555'&gt;"+"阅读次数："+time+"&lt;/font&gt;"+"&lt;br /&gt;&lt;br /&gt;"; document.getElementById("top").innerHTML+=content &#125; &#125;, function (error) &#123; console.log("error"); &#125;);&lt;/script&gt;&lt;style&gt;.post-description &#123; display: none; &#125;&lt;/style&gt; 必须将里面的里面的app_id和app_key替换为你的主题配置文件中的值，必须替换里面博客的链接，1000是显示文章的数量，其它可以自己看情况更改。 最后，修改样式可以在custom.styl中加入自定义代码。 Okay! 完成了！ 利用 gulp 压缩代码右键查看网页源代码发现有大量留白，咋整？利用 gulp。 首先任意目录全局安装： 1npm install gulp -g 然后到站点文件夹根目录： 1所在目录：~/blog/npm install gulp gulp-minify-css gulp-htmlmin gulp-htmlclean --save 接着在站点文件夹根目录新建 gulpfile.js： 123456789101112131415161718192021文件位置：~/blog/gulpfile.jsvar gulp = require('gulp');var minifycss = require('gulp-minify-css');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');gulp.task('minify-css', function() &#123; return gulp.src('./public/**/*.css') .pipe(minifycss()) .pipe(gulp.dest('./public'))&#125;);gulp.task('minify-html', function() &#123; return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true &#125;)) .pipe(gulp.dest('./public'))&#125;);gulp.task('default', ['minify-html', 'minify-css']); 最后部署到 GitHub Pages 上查看效果： 1所在目录：~/blog/hexo clean &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo d 我没有压缩 JavaScript，因为我发现会报错，实际也并不需要，因为大部分 JavaScript 都已压缩过。 这里的这段代码执行 gulp 后不支持 hexo s 本地调试，记得在哪看过解决方法，需要的自己 Google。 另外，可能会产生一些奇怪的 bugs，没看到最好，要是看到了的话就自己解决吧～[逃……] 让页脚的心跳动起来世界上有一种伟大的力量，它的名字无人不晓，就是……爱～ 更新 NexT 主题后，发现默认的icon变成了（user），不过这可阻挡不了爱的力量！ 首先编辑主题配置文件： 123文件位置：~/blog/themes/next/_config.ymlfooter:- icon: user+ icon: heart 然后编辑： 12文件位置：~/blog/themes/next/layout/_partials/footer.swig- &lt;span class="with-love"&gt;+ &lt;span class="with-love" id="heart"&gt; 接着编辑custom.styl，加入： 12345678910111213文件位置：~/blog/themes/next/source/css/_custom/custom.styl// 自定义页脚跳动的心样式@keyframes heartAnimate &#123; 0%,100%&#123;transform:scale(1);&#125; 10%,30%&#123;transform:scale(0.9);&#125; 20%,40%,60%,80%&#123;transform:scale(1.1);&#125; 50%,70%&#123;transform:scale(1.1);&#125;&#125;#heart &#123; animation: heartAnimate 1.33s ease-in-out infinite;&#125;.with-love &#123; color: rgb(255, 113, 168);&#125; 页脚加上微信二维码主题默认的微信订阅个人感觉不美观，看到很多网站都是在页脚有个微信的 Logo，然后鼠标移动到上面便会显示二维码，这样感觉很棒。 首先编辑文件，在文件最后加上下面代码： 1234567文件位置：~/blog/themes/next/layout/_partials/footer.swig&lt;div class="weixin-box"&gt; &lt;div class="weixin-menu"&gt; &lt;div class="weixin-hover"&gt; &lt;div class="weixin-description"&gt;微信扫一扫，订阅本博客&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 然后编辑custom.styl，加入： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051文件位置：~/blog/themes/next/source/css/_custom/custom.styl// 自定义的页脚微信订阅号样式.weixin-box &#123; position: absolute; bottom: 43px; left: 10px; border-radius: 5px; box-shadow: 0px 0px 10px 0px rgba(0, 0, 0, 0.35);&#125;.weixin-menu &#123; position: relative; height: 24px; width: 24px; cursor: pointer; background: url(https://微信的logo.svg); background-size: 24px 24px;&#125;.weixin-hover &#123; position: absolute; bottom: 0px; left: 0px; height: 0px; width: 0px; border-radius: 3px; box-shadow: 0px 0px 10px 0px rgba(0, 0, 0, 0.35); background: url(https://二维码.svg); background-color: #fff; background-repeat: no-repeat; background-size: 150px 150px; transition: all 0.35s ease-in-out; z-index: 1024; opacity: 0;&#125;.weixin-menu:hover .weixin-hover &#123; bottom: 24px; left: 24px; height: 170px; width: 150px; opacity: 1;&#125;.weixin-description &#123; opacity: 0; position: absolute; bottom: 3%; left: 5%; right: 5%; font-size: 12px; transition: all 0.35s cubic-bezier(1, 0, 0, 1);&#125;.weixin-menu:hover .weixin-description &#123; opacity: 1;&#125; 图片务必用矢量图 svg 格式，否则手机上显示效果很差，其它的自己看情况更改。 更改标签云（tagcloud）的颜色如果你和我一样个性化了博客的整体布局颜色，那么默认的标签云页面可能看起来很丑，怎么更改？ 修改下文件： 1文件位置：~/blog/themes/next/layout/page.swig&#123;&#123; tagcloud(&#123;min_font: 13, max_font: 31, amount: 1000, color: true, start_color: '#9733EE', end_color: '#FF512F'&#125;) &#125;&#125; 修改对应参数值即可，参数说明见 Hexo 官方文档，颜色可以参考这个网站，自己去纠结…… 点击侧栏头像回到博客首页不知道为什么，我看到侧栏头像的第一反应是点击，然后心理预期会跳到博客首页，可惜也仅是预期，那么开始动手吧～ 首先要在主题配置文件中配置好，比如我把头像avatar.gif放在~/blog/source/uploads/下，则： 12345文件位置：~/blog/themes/next/_config.yml# Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gif-#avatar: /images/avatar.gif+avatar: /uploads/avatar.gif 然后编辑文件： 12345文件位置：~/blog/themes/next/layout/_macro/sidebar.swig+ &lt;a href="/"&gt; &lt;img class="site-author-image" itemprop="image" src="&#123;&#123; url_for( theme.avatar | default(theme.images + '/avatar.gif') ) &#125;&#125;" alt="&#123;&#123; theme.author &#125;&#125;" /&gt;+ &lt;/a&gt; 最后就 OK 了～ 文章摘要图片俗话说：“图文并茂”，现实中用笔书写文章实现起来比较困难，但在博客上可以很轻松实现. 首先，文章摘要（excerpt）是指每篇文章在页面（page）上显示的那部分内容，也就是 [Read More] 之前的文章内容。由于它会展示在页面，因此在每篇文章的文章摘要中加一张图片，页面看起来就很美观。 但是有时候可能会出现一个问题：你想从文章中选一张图片作为文章摘要图片，而这张图片由于写作要求，必须添加在文章的末尾，这样点 [Read More] 查看文章时，这张图片就会重复出现了。咋办？ 前提是在主题配置文件中： 1234文件位置：~/blog/themes/next/_config.ymlexcerpt_description: falseauto_excerpt: enable: false 首先加代码： 1234567891011121314151617181920212223242526文件位置：~/blog/themes/next/layout/_macro/post.swig &#123;% if is_index %&#125; &#123;% if post.description and theme.excerpt_description %&#125; &#123;&#123; post.description &#125;&#125; &lt;!--noindex--&gt; &lt;div class="post-button text-center"&gt; &lt;a class="btn" href="&#123;&#123; url_for(post.path) &#125;&#125;"&gt; &#123;&#123; __('post.read_more') &#125;&#125; &amp;raquo; &lt;/a&gt; &lt;/div&gt; &lt;!--/noindex--&gt; &#123;% elif post.excerpt %&#125; &#123;&#123; post.excerpt &#125;&#125;+ + &#123;% if post.image %&#125;+ &lt;div class="out-img-topic"&gt;+ &lt;img src=&#123;&#123; post.image &#125;&#125; class="img-topic" /&gt;+ &lt;/div&gt;+ &#123;% endif %&#125;+ &lt;!--noindex--&gt; &lt;div class="post-button text-center"&gt; &lt;a class="btn" href="&#123;&#123; url_for(post.path) &#125;&#125;&#123;% if theme.scroll_to_more %&#125;#&#123;&#123; __('post.more') &#125;&#125;&#123;% endif %&#125;" rel="contents"&gt; &#123;&#123; __('post.read_more') &#125;&#125; &amp;raquo; &lt;/a&gt; &lt;/div&gt; &lt;!--/noindex--&gt; 为了防止有的图片宽度不够导致风格不够统一，页面不美观，需要在custom.styl中加入： 1234文件位置：~/blog/themes/next/source/css/_custom/custom.styl// 自定义的文章摘要图片样式img.img-topic &#123; width: 100%;&#125; 最后编辑有这需求的相关文章时，在Front-matter（文件最上方以---分隔的区域）加上一行： 1image: url url即图片的链接地址～ 文章置顶由于博客的首页可能是被浏览最多的页面，所以首页的前几篇文章被阅读的可能性比较大。可以利用这个特点，通过将自己认为重要的文章放在首页，从而让重要的文章被阅读的可能性增大。 但是，默认的排序只有一个维度——时间，两种选择——正序和倒序，这就造成自己的得意之作被“埋没”了，怎么办呢，如何实现文章的置顶？ NexT 主题以前有过这个功能，然而由于一些bugs（issue）被去掉了。不过在这个丰富的 issue 中，我自己摸索出了一种解决方法，参考了 issue 中的那篇文章。 首先移除默认安装的插件： 1所在目录：~/blog/npm uninstall hexo-generator-index --save 然后安装新插件： 1所在目录：~/blog/npm install hexo-generator-index-pin-top --save 最后编辑有这需求的相关文章时，在Front-matter（文件最上方以---分隔的区域）加上一行： 1top: true 然后就行了，如果你置顶了多篇，怎么控制顺序呢？设置top的值（大的在前面），比如： 1234567# Post a.mdtitle: atop: 1# Post b.mdtitle: btop: 10 那么文章 b 便会显示在文章 a 的前面。 可是，没有任何标记啊，读者怎么知道文章置顶了～ 还好 NexT 原有的置顶功能有考虑到这个，且置顶的样式没有被移除，所以可以直接利用，编辑文件： 12345678910111213141516171819202122232425262728文件位置：~/blog/node_modules/hexo-generator-index-pin-top/lib/generator.js'use strict';var pagination = require('hexo-pagination');module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.sticky &amp;&amp; b.sticky) &#123; // 两篇文章sticky都有定义 if(a.sticky == b.sticky) return b.date - a.date; // 若sticky值一样则按照文章日期降序排 else return b.sticky - a.sticky; // 否则按照sticky值降序排 &#125; else if(a.sticky &amp;&amp; !b.sticky) &#123; // 以下是只有一篇文章sticky有定义，那么将有sticky的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.sticky &amp;&amp; b.sticky) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 也就是将插件的top全部替换为 NexT 原有的sticky，然后将Front-matter中的top替换为sticky，就能调用 NexT 主题原有的置顶样式了。 最后可以自定义一下样式： 12345678910111213文件位置：~/blog/themes/next/source/css/_custom/custom.styl// 自定义的文章置顶样式.post-sticky-flag &#123; font-size: inherit; float: left; color: rgb(0, 0, 0); cursor: help; transition-duration: 0.2s; transition-timing-function: ease-in-out; transition-delay: 0s;&#125;.post-sticky-flag:hover &#123; color: #07b39b;&#125; 已发现的 bug：新安装的插件无法实现站点配置文件中order_by: date，即文章按时间从旧到新排列的配置，也就意味着文章只能按默认的时间从新到旧排列。 背景图片通过 jquery-backstretch，具体操作呢，编辑文件： 12345文件位置：~/blog/themes/next/layout/_layout.swig+ &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js"&gt;&lt;/script&gt;;+ &lt;script&gt;+ $("body").backstretch("https://背景图.jpg");+ &lt;/script&gt;&lt;/body&gt; 加入到文件最后面&lt;/body&gt;前面即可。 你可以浏览器按 F12 查看我的页面，就可以在&lt;/body&gt;前发现。 幻灯片等更多用法请自行查看 GitHub 上的 README。 动态效果可以在主题配置文件_config.yml里的motion中配置，但是如果你和我一样更改了博客的背景色，可能不能达到很好的效果，怎么办呢？参考这里，修改下面两个文件的相应内容。 ~/blog/themes/next/source/css/_common/components/post/post.styl ~/blog/themes/next/source/js/src/motion.js]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F14%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot.JavaMail]]></title>
    <url>%2F2018%2F12%2F01%2FSpringBoot-JavaMail%2F</url>
    <content type="text"><![CDATA[JavaMail是SUN提供给广大Java开发人员的一款邮件发送和接受的一款开源类库，支持常用的邮件协议，如：SMTP、POP3、IMAP，开发人员使用JavaMail编写邮件程序时，不再需要考虑底层的通讯细节如：Socket而是关注在逻辑层面。JavaMail可以发送各种复杂MIME格式的邮件内容，注意JavaMail仅支持JDK4及以上版本。虽然JavaMail是JDK的API但它并没有直接加入JDK中，所以我们需要另外添加依赖。 本章目标将Java提供的JavaMail类库与SpringBoot项目进行整合，并且简单封装下JavaMail类库。 构建项目本章项目无关Web相关内容，所以创建项目时选择Jar形式创建，并且不需要预先导入依赖，项目初始化多余的依赖并没有添加，如果你选择的是War项目也没有关系，那好，我们接下来把我们的主角JavaMail请出来吧，把对应的依赖添加到pom.xml配置文件内。如下所示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-example&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;spring-boot-example&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;--JavaMail--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.mail&lt;/groupId&gt; &lt;artifactId&gt;mail&lt;/artifactId&gt; &lt;version&gt;1.4.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 依赖我们已经导入成功了，接下来我们开始编写JavaMail的封装，我这里简单的对JavaMail做出封装，如果您需要更完美的封装，请对我的代码做出修改即可，先来编写一个MailEntity类来保存发送邮件时需要的参数字段，如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import java.io.Serializable;import java.util.ArrayList;import java.util.List;public class MailEntity implements Serializable &#123; //此处填写SMTP服务器 private String smtpService; //设置端口号 private String smtpPort; //设置发送邮箱地址 private String fromMailAddress; //设置发送邮箱SMTP口令 private String fromMailStmpPwd; //设置邮件标题 private String title; //设置邮件内容 private String content; //内容格式（默认采用html） private String contentType; //接收邮件地址集合 private List&lt;String&gt; list = new ArrayList&lt;&gt;(); public String getSmtpService() &#123; return smtpService; &#125; public void setSmtpService(String smtpService) &#123; this.smtpService = smtpService; &#125; public String getSmtpPort() &#123; return smtpPort; &#125; public void setSmtpPort(String smtpPort) &#123; this.smtpPort = smtpPort; &#125; public String getFromMailAddress() &#123; return fromMailAddress; &#125; public void setFromMailAddress(String fromMailAddress) &#123; this.fromMailAddress = fromMailAddress; &#125; public String getFromMailStmpPwd() &#123; return fromMailStmpPwd; &#125; public void setFromMailStmpPwd(String fromMailStmpPwd) &#123; this.fromMailStmpPwd = fromMailStmpPwd; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125; public String getContentType() &#123; return contentType; &#125; public void setContentType(String contentType) &#123; this.contentType = contentType; &#125; public List&lt;String&gt; getList() &#123; return list; &#125; public void setList(List&lt;String&gt; list) &#123; this.list = list; &#125;&#125; 我们的MailEntity包含了上图3的字段内容，都是一些必填选项，下面我们来创建一个MailSender也就是邮件发送者实体，主要作用就是用来配置发送邮件参数以及执行发送邮件，代码如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121import com.example.springbootexample.Mail.Until.PropertiesUtil;import javax.mail.*;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeMessage;import javax.mail.internet.MimeUtility;import java.util.List;import java.util.Properties;import com.sun.mail.util.MailSSLSocketFactory;public class MailSender &#123; //邮件实体 private static MailEntity mail = new MailEntity(); //设置邮件标题 public MailSender title(String title) &#123; mail.setTitle(title); return this; &#125; //设置邮件内容 public MailSender content(String content) &#123; mail.setContent(content); return this; &#125; //设置邮件格式 public MailSender cpntentType(MailContentEnum typeEnum) &#123; mail.setContentType(typeEnum.getValue()); return this; &#125; //设置请求邮件地址 public MailSender targets(List&lt;String&gt; targets) &#123; mail.setList(targets); return this; &#125; //执行发送邮件 public void send() throws Exception &#123; //默认使用html发送 if (mail.getContentType() == null) &#123; mail.setContentType(MailContentEnum.HTML.getValue()); &#125; if (mail.getTitle() == null || mail.getTitle().trim().length() == 0) &#123; throw new Exception("邮件标题没有设置，请设置有邮件标题"); &#125; if (mail.getContent() == null || mail.getContent().trim().length() == 0) &#123; throw new Exception("邮件内容没有设置，请设置邮件内容"); &#125; if (mail.getList().size() == 0) &#123; throw new Exception("没有接收者邮箱地址"); &#125; //读取/resource/mall_zh_CN.properties中的内容 final PropertiesUtil properties = new PropertiesUtil("mail"); //创建Properties类用于记录邮箱的一些属性 final Properties props = new Properties(); // 关于QQ邮箱，还要设置SSL加密，加上以下代码即可 MailSSLSocketFactory sf = new MailSSLSocketFactory(); sf.setTrustAllHosts(true); props.put("mail.smtp.ssl.enable", "true"); props.put("mail.smtp.ssl.socketFactory", sf); //表示SMTP发送邮件，必须进行身份验证 props.put("mail.smtp.auth", "true"); //此处填写smtp服务器 props.put("mail.smtp.host", properties.getValue("mail.smtp.service")); //设置端口。QQ邮箱给出的俩个端口465//587 props.put("mail.smtp.port", properties.getValue("mail.smtp.port")); //设置发送邮箱 props.put("mail.user", properties.getValue("mail.from.address")); //设置发送邮箱的16位SMTP口令 props.put("mail.password", properties.getValue("mail.from.smtp.pwd")); //构建授权信息，用于进行SMTP省份验证 Authenticator authenticator = new Authenticator() &#123; @Override protected PasswordAuthentication getPasswordAuthentication() &#123; //用户名，密码 String userName = props.getProperty("mail.user"); String passWord = props.getProperty("mail.password"); return new PasswordAuthentication(userName, passWord); &#125; &#125;; //使用环境属性和授权信息，创建邮件会话 Session mailSession = Session.getInstance(props, authenticator); mailSession.setDebug(true); //创建邮件消息 MimeMessage message = new MimeMessage(mailSession); //设置发件人 String nickName = MimeUtility.encodeText(properties.getValue("mail.from.nickname")); InternetAddress form = new InternetAddress(nickName + "&lt;" + props.getProperty("mail.user") + "&gt;"); message.setFrom(form); //设置邮件标题 message.setSubject(mail.getTitle()); //html发送邮件 if (mail.getContentType().equals(MailContentEnum.HTML.getValue())) &#123; //设置邮件标题 message.setContent(mail.getContent(), mail.getContentType()); &#125; //文本发送邮件 else if (mail.getContentType().equals(MailContentEnum.TEXT.getValue())) &#123; message.setText(mail.getContent()); &#125; //发送邮箱地址 List&lt;String&gt; targets = mail.getList(); for (int i = 0; i &lt; targets.size(); i++) &#123; try &#123; //设置收件人的邮箱 InternetAddress to = new InternetAddress(targets.get(i)); message.setRecipients(Message.RecipientType.TO, new InternetAddress[]&#123;to&#125;); //发送邮件 Transport.send(message); &#125; catch (Exception e) &#123; continue; &#125; &#125; &#125;&#125; 因为简书的富文本编辑器不支持代码块，下次编写文章使用MarkDown方式来写，类过长贴起来图挺费劲。上面可以看到我使用到了MailContentTypeEnum以及PropertiesUtil工具类。 MailContentTypeEnum这是一个我自定义的枚举类型，枚举类型包含了邮件内容的类型，目前我仅仅添加了两种，一种是html另外一种则是text形式，具体代码如下所示： 123456789101112131415public enumMailContentEnum &#123; TEXT("text"), HTML("text/html;charset=UTF-8"); private String value; MailContentEnum(String value) &#123; this.value = value; &#125; public String getValue() &#123; return value; &#125;&#125; PropertiesUtilPropertiesUtil是用于读取*.properties配置文件的工具类，使用JavaMail需要配置SMTP以及用户名、密码等也就是MailEntity内的字段，那么我们在/resource目录下创建一个名字叫mail.properties的配置文件，里面存放我们定义的邮件发送参数配置，这样方便修改，我分别贴出PropertiesUtil、mail.properties代码内容，如下所示： 123456789101112131415161718192021import java.util.Locale;import java.util.ResourceBundle;public class PropertiesUtil &#123; private ResourceBundle resource = null; private final String fileName; //获取文件资源对象 public PropertiesUtil(String fileName) &#123; this.fileName = fileName; Locale locale = new Locale("zh", "CN"); this.resource = ResourceBundle.getBundle(this.fileName, locale); &#125; //key value public String getValue(String key) &#123; String message = this.resource.getString(key); return message; &#125;&#125; 12345678910#对应发送服务器的smtp服务器地址mail.smtp.service=smtp.qq.com#对应服务器的smtp服务端口号mail.smtp.port=465#发件人邮箱地址mail.from.address=809962111@qq.com#smtp授权密码mail.from.smtp.pwd= // smtp授权密码#发件人邮箱显示昵称mail.from.nickname=aaa 我使用的QQ邮箱地址作为测试，如果你需要使用你的QQ地址作为测试，请先到QQ邮箱开启POP3/SMTP服务，开启步骤如下。 开启POP3/SMTP第一步：进入邮箱点击“设置”，如下图所示： 第二部：点击“账户”。 第三步：获取授权码。 我的POP3以及SMTP以及开启了所以这里显示的状态是已开启，如果您第一次使用QQ邮箱的SMTP服务，请点击“开启”并且按照提示步骤完成获取“授权码”即可，授权码就是发送邮件参数的smtp.pwd属性。 测试发送邮件我们创建一个sendMailTo类来作为测试入口，因为我们的项目是jar形式，所以我们直接新建一个main方法直接调用发送邮件就可以了，如下所示测试代码： 123456789101112131415161718import com.example.springbootexample.Mail.Config.MailContentEnum;import com.example.springbootexample.Mail.Config.MailSender;import java.util.ArrayList;public class sendMailTo &#123; public static void main(String[] args) throws Exception &#123; new MailSender() .title("测试SpringBoot发送邮件") .content("简单文本内容发送") .cpntentType(MailContentEnum.TEXT) .targets(new ArrayList&lt;String&gt;() &#123;&#123; add("895800655@qq.com"); &#125;&#125;) .send(); &#125;&#125; 我是向我的895800655@qq.com邮箱发送了一条文本类型的测试邮件，发送效果图如下图所示：]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何通过Hexo与GitHub搭建属于自己的博客]]></title>
    <url>%2F2018%2F11%2F28%2FHexoAndGit%2F</url>
    <content type="text"><![CDATA[关于博客写博客对于程序猿来说，应该是个优秀的习惯，个人也觉得蛮高大上的 ^_^。网上的博客论坛网站也多种多样，个人觉得在长久以来的不断竞争淘汰中，各大网站的功能等可能都相差无几了，选择自己稍微偏好的就可以了。 我的个人情况就是结合Hexo和Github Pages的独立个人博客网页，因为听说拥有自己的Github主页也是一件蛮高大上的事 -_- 。 关于Hexo Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Heroku上，是搭建博客的首选框架。这里我们选用的是GitHub，你没看错，全球最大的同性恋交友网站（逃……）。Hexo同时也是GitHub上的开源项目，参见：hexojs/hexo 如果想要更加全面的了解Hexo，可以到其官网 Hexo 了解更多的细节，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。这里，默认各位猿/媛儿都知道GitHub就不再赘述。 关于Github然后简单介绍一下Github以及其Github Pages功能。GitHub是一个面向开源及私有软件项目的托管平台，也是一个分布式版本控制系统，详情见百度百科。说到分布式，自然也有另外一种集中式版本控制系统：SVN，有兴趣小伙伴可以了解百度百科。GIt是SVN的发展版，而且现在主流也是GIt，但某些大公司依然在使用SVN，二者各有优劣，自行体会，此处不做详解，用一张图简单说明： GIthub Pages则是github上的一项功能，可以放置网页文件到指定文件夹，然后给你一个专属域名用于展示一些项目，但现在大多用来开发制作个人博客网站。接下来就一步步按照我曾经的步骤来搭建个人博客，顺便讲讲沿途遇到过的坑，如没有的提及请自行百度。 搭建步骤： 搭建环境准备（包括node.js和git环境，gitHub账户的配置） 配置Hexo 配置GitHub 常用命令 搭建环境 安装git 可以到git官网下载相应平台的版本进行安装。考虑到你可能是无照驾驶，直接在github/git下载。 申请github账号 进入github注册。此处省略一千字。 安装node.js, 到node.js官网下载相应平台的最新版本，傻瓜式安装（自带安装npm）。 安装hexo 打开git bash或者cmd，执行以下命令: 1npm install -g hexo-cli ​ 如果没有错误提示，那么在git的交互环境输入以下命令查看git版本： 1hexo version 配置Hexo首先创建一个文件夹，如blog，用来存放hexo的配置文件等，然后进入blog进行操作。 初始化 右键 git bash，执行以下命令: 1hexo init 安装依赖包 1npm install 生成静态页面 1hexo generate 或者 hexo g 本地运行 1hexo server 或者 hexo s 打开浏览器，在地址栏输入localhost:4000，就可以看到我们搭建好的本地博客了。到此只是搭建好了本地博客，还需要将博客部署到github上。 配置GitHub 新建repository 建立与你用户名对应的仓库，仓库名必须为【 your_username.github.io】 。 部署博客进入你的hexo文件夹根目录下，用编辑器打开_config.yml，修改deploy项，如下（根据你的github进行相应更改）： 1234deploy: type: git #注意：有的版本type是github repo: https://github.com/你的账户名/你的账户名.github.io.git branch: master 此时就完成部署了，用浏览器访问xiaobinhong1.github.io即可(第一次发布可能会有10分钟的延迟)。每次修改完本地的文件后要执行以下命令，重新部署到github上： 123hexo clean hexo generate hexo deploy 或者 hexo d 常用命令1234567hexo new “postName” // 新建文章 hexo new page “pageName” // 新建页面 hexo generate // 生成静态页面至public目录hexo server // 开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy // 将.deploy目录部署到GitHubhexo help // 查看帮助hexo version // 查看Hexo的版本]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
