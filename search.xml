<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Shell学习]]></title>
    <url>%2F2020%2F09%2F12%2FShell%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Shell学习笔记linux中使用git 先在本地生成ssh key，生成公钥和私钥，后续在github等代码托管配置中需要用到 1ssh-keygen -t rsa -C "your_email@youremail.com" 确认路径按1次回车，提示：Enter passphrase（输入密码），不用输密码再按2次回车即可。生成的密钥存放路径 /root/.ssh/id_rsa 1cat /root/.ssh/id_rsa.pub 安装 1yum install git 验证 123[root@localhost ~]# git --versiongit version 1.8.3.1[root@localhost ~]# 配置基本信息 12345678//配置基本信息[root@localhost ~]# git config --global user.name "flymegoc"[root@localhost ~]# git config --global user.email 343672271@qq.com//查看配置[root@localhost ~]# git config --listuser.name=flymegocuser.email=343672271@qq.com[root@localhost ~]# 配置SSH用于拉取远程仓库 1TypeError: from_buffer() cannot return the address of the raw string within a str or unicode object 解决办法 1pip install --upgrade pyOpenSSl 查看网卡信息、配置ip查看网卡信息： 1ethtool -i eth0 展示ip参数 1ip addr show 安装ifconfig工具 1234#通过以下命令搜索安装包yum search ifconfig#然后安装net-tools.*，根据实际查找出来的包安装yum install net-tools.* 配置ip地址 12ifconfig eth0 192.168.249.131 netmask 255.255.255.0route add default gw 192.168.249.2 删除一个网卡的IP 1ip addr flush dev eth0 调试shell程序 1vi /etc/sys.init.d/sys_package 1set -x 1echo "------------------------------" 1/bin/bash /bin/pxe_autorun &gt;&gt; /tmp/1 2&gt;&amp;1 1vi /tmp/1 在Linux下查看硬盘的方式有很多: 1.fdisk -l2.lsblk 如果使用的是scsi接口的可以使用: 3.lsscsi smartctl会查看sda具体信息,包括型号,sn，firmware等 4.smartctl -a /dev/sda 如果有RAID，请通过对应的RAID管理（监控）工具查看，例如LSI的MegaCli 5.MegaCli -PDList -aALL 通过hdparm命令查看指定硬盘的型号 6.hdparm -i /dev/hda 查看系统信息12345678910111213141516##查看centos系统版本命令[root@LAMP1 config]# cat /proc/version Linux version 2.6.32-279.el6.x86_64 (mockbuild@c6b9.bsys.dev.centos.org) (gcc version 4.4.6 20120305 (Red Hat 4.4.6-4) (GCC) ) #1 SMP Fri Jun 22 12:19:21 UTC 2012[root@LAMP1 config]# uname -aLinux LAMP1.1 2.6.32-279.el6.x86_64 #1 SMP Fri Jun 22 12:19:21 UTC 2012 x86_64 x86_64 x86_64 GNU/Linux[root@LAMP1 config]# uname -r2.6.32-279.el6.x86_64[root@LAMP1 config]# ##查看版本：[root@LAMP1 config]# cat /etc/issueCentOS release 6.3 (Final)Kernel \r on an \m[root@LAMP1 config]# cat /etc/redhat-release CentOS release 6.3 (Final)[root@LAMP1 config]# 12[root@974ca3d2c5dd /]# systemctl status vsftpdFailed to get D-Bus connection: Operation not permitted 查看进程、端口号1234567891011#查看程序进程 ps -ef|grep zookeeper#查看端口号 netstat -anp|grep 2181#查看端口号 lsof -i:2181#查看进程pidpgrep -f vsftpd shell中可能经常能看到：echo log &gt; /dev/null 2&gt;&amp;1命令的结果可以通过%&gt;的形式来定义输出 /dev/null ：代表空设备文件 &gt; ：代表重定向到哪里，例如：echo “123” &gt; /home/123.txt 1 ：表示stdout标准输出，系统默认值是1，所以”&gt;/dev/null”等同于”1&gt;/dev/null” 2 ：表示stderr标准错误 &amp; ：表示等同于的意思，2&gt;&amp;1，表示2的输出重定向等同于1 1 &gt; /dev/null 2&gt;&amp;1 语句含义： 1 &gt; /dev/null ： 首先表示标准输出重定向到空设备文件，也就是不输出任何信息到终端，说白了就是不显示任何信息。 2&gt;&amp;1 ：接着，标准错误输出重定向（等同于）标准输出，因为之前标准输出已经重定向到了空设备文件，所以标准错误输出也重定向到空设备文件。 实例解析： cmd &gt;a 2&gt;a 和 cmd &gt;a 2&gt;&amp;1 为什么不同？ cmd &gt;a 2&gt;a ：stdout和stderr都直接送往文件 a ，a文件会被打开两遍，由此导致stdout和stderr互相覆盖。 cmd &gt;a 2&gt;&amp;1 ：stdout直接送往文件a ，stderr是继承了FD1的管道之后，再被送往文件a 。a文件只被打开一遍，就是FD1将其打开。 两者的不同点在于： cmd &gt;a 2&gt;a 相当于使用了FD1、FD2两个互相竞争使用文件 a 的管道； cmd &gt;a 2&gt;&amp;1 只使用了一个管道FD1，但已经包括了stdout和stderr。 从IO效率上来讲，cmd &gt;a 2&gt;&amp;1的效率更高。经常可以在一些脚本，尤其是在crontab调用时发现如下形式的命令调用 /tmp/test.sh &gt; /tmp/test.log 2&gt;&amp;1前半部分/tmp/test.sh &gt; /tmp/test.log很容易理解，那么后面的2&gt;&amp;1是怎么回事呢？ 要解释这个问题，还是得提到文件重定向。我们知道&gt;和&lt;是文件重定向符。那么1和2是什么？ 在shell中，每个进程都和三个系统文件 相关联：标准输入stdin，标准输出stdout、标准错误stderr，三个系统文件的文件描述符分别为0，1、2。所以这里2&gt;&amp;1 的意思就是将标准错误也输出到标准输出当中。 为何2&gt;&amp;1要写在后面？ command &gt; file 2&gt;&amp;1首先是command &gt; file将标准输出重定向到file中， 2&gt;&amp;1 是标准错误拷贝了标准输出的行为，也就是同样被重定向到file中，最终结果就是标准输出和错误都被重定向到file中。 command 2&gt;&amp;1 &gt;file2&gt;&amp;1 标准错误拷贝了标准输出的行为，但此时标准输出还是在终端。&gt;file 后输出才被重定向到file，但标准错误仍然保持在终端。 用strace可以看到： command &gt; file 2&gt;&amp;1这个命令中实现重定向的关键系统调用序列是：open(file) == 3dup2(3,1)dup2(1,2) command 2&gt;&amp;1 &gt;file这个命令中实现重定向的关键系统调用序列是：dup2(1,2)open(file) == 3dup2(3,1) 如何使用yum下载rpm包使用yum插件Downloadonly下载rpm包和依赖包 12yum install yum-plugin-downloadonlyyum install --downloadonly --downloaddir=&lt;directory&gt; &lt;package-name&gt; DHCP、TFTP、VSFTP默认端口号 DHCP用的端号是UDP67和UDP68，这两bai个端口是正常du的DHCP服务端口，你可以理zhi解为一个发送，一个接收dao。客户端向68端口（bootps）广播请求配置，服务器向67端口（bootpc）广播回应请求。 TFTP（Trivial File Transfer Protocol,简单文件传输协议）是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。 端口号为69。 vsftpd启动后，默认的ftp端口是21 shell 脚本中的$@和$#$@：表示所有参数；$#表示所有参数的个数 Linux 之 shell 比较运算符 运算符 描述 示例 文件比较运算符 -e filename 如果 filename 存在，则为真 [ -e /var/log/syslog ] -d filename 如果 filename 为目录，则为真 [ -d /tmp/mydir ] -f filename 如果 filename 为常规文件，则为真 [ -f /usr/bin/grep ] -L filename 如果 filename 为符号链接，则为真 [ -L /usr/bin/grep ] -r filename 如果 filename 可读，则为真 [ -r /var/log/syslog ] -w filename 如果 filename 可写，则为真 [ -w /var/mytmp.txt ] -x filename 如果 filename 可执行，则为真 [ -L /usr/bin/grep ] filename1 -nt filename2 如果 filename1 比 filename2 新，则为真 [ /tmp/install/etc/services -nt /etc/services ] filename1 -ot filename2 如果 filename1 比 filename2 旧，则为真 [ /boot/bzImage -ot arch/i386/boot/bzImage ] 字符串比较运算符 （请注意引号的使用，这是防止空格扰乱代码的好方法） -z string 如果 string 长度为零，则为真 [ -z “$myvar” ] -n string 如果 string 长度非零，则为真 [ -n “$myvar” ] string1 = string2 如果 string1 与 string2 相同，则为真 [ “$myvar” = “one two three” ] string1 != string2 如果 string1 与 string2 不同，则为真 [ “$myvar” != “one two three” ] 算术比较运算符 num1 -eq num2 等于，则为真 [ 3 -eq $mynum ] num1 -ne num2 不等于，则为真 [ 3 -ne $mynum ] num1 -lt num2 小于，则为真 [ 3 -lt $mynum ] num1 -le num2 小于或等于，则为真 [ 3 -le $mynum ] num1 -gt num2 大于，则为真 [ 3 -gt $mynum ] num1 -ge num2 大于或等于，则为真 [ 3 -ge $mynum ] Shell 中的中括号用法总结 匹配字符 []#匹配一个指定范围内的字符，如’[Gg]rep’匹配Grep和grep。 1234[root@localhost test]# lsabb.sh Dest1.sh test1.sh[root@localhost test]# ls [tD]est1.shDest1.sh test1.sh [[支持字符串的模式匹配，使用=~操作符时甚至支持shell的正则表达式。字符串比较时可以把右边的作为一个模式，而不仅仅是一个字符串，比如[[ hello == hell? ]]，结果为真。[[ ]] 中匹配字符串或通配符，不需要引号。 123456$[[ 'abcd' == a*d ]] &amp;&amp; echo True || echo FalseTrue$[ 'abcd' == a*d ] &amp;&amp; echo True || echo FalseFalse Shell 里面的中括号（包括单中括号与双中括号）可用于一些条件的测试： 算术比较, 比如一个变量是否为0, [ $var -eq 0 ]。 文件属性测试，比如一个文件是否存在，[ -e $var ], 是否是目录，[ -d $var ]。 字符串比较, 比如两个字符串是否相同， [[ $var1 = $var2 ]]。 方括号 方括号定义了测试条件。 第一个方括号后和第二个方括号前都要加一个空格，否则会报错。 方括号主要包括4类判断： 数值比较 字符串比较 文件比较 符合条件比较 12[ condition1 ] &amp;&amp; [ condition2 ][ condition1 ] || [ condition2 ] 双方括号 双方括号提供了字符串比较的高级特性。 括号中可以定义一些正则表达式来匹配字符串 注意不是所有的shell都支持双方括号！ 在[[中使用&amp;&amp;和||表示逻辑与和逻辑或。[中使用-a 和-o 表示逻辑与和逻辑或。 123456789101112131415x=1y=1$[ $x == 1 &amp;&amp; $y == 1 ] &amp;&amp; echo True || echo False-bash: [: missing `]'False$[[ $x == 1 &amp;&amp; $y == 1 ]] &amp;&amp; echo True || echo FalseTrue$[ $x == 1 -a $y == 1 ] &amp;&amp; echo True || echo FalseTrue 总结： 使用[[ … ]]条件判断结构，而不是[ … ]，能够防止脚本中的许多逻辑错误。比如，&amp;&amp;、||、&lt;和&gt; 操作符能够正常存在于[[ ]]条件判断结构中， 但是如果出现在[ ]结构中的话，会报错。比如可以直接使用if [[ $a != 1 &amp;&amp; $a != 2 ]] 如果不使用双括号, 则为if [ $a -ne 1] &amp;&amp; [ $a != 2 ]或者if [ $a -ne 1 -a $a != 2 ] bash把双中括号中的表达式看作一个单独的元素，并返回一个退出状态码。]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python笔记]]></title>
    <url>%2F2020%2F09%2F05%2FPython%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Python笔记静态语言与动态语言静态语言（强类型语言） 静态语言是在编译时变量的数据类型即可确定的语言，多数静态类型语言要求在使用变量之前必须声明数据类型。 例如：C++、Java、Delphi、C#等。 动态语言（弱类型语言） 动态语言是在运行时确定数据类型的语言。变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型。 例如PHP/ASP/Ruby/Python/Perl/ABAP/SQL/JavaScript/Unix Shell等等。 强类型定义语言 强制数据类型定义的语言。也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。举个例子：如果你定义了一个整型变量a,那么程序根本不可能将a当作字符串类型处理。强类型定义语言是类型安全的语言。 弱类型定义语言 数据类型可以被忽略的语言。它与强类型定义语言相反, 一个变量可以赋不同数据类型的值。强类型定义语言在速度上可能略逊色于弱类型定义语言，但是强类型定义语言带来的严谨性能够有效的避免许多错误。 两者区别 特性 强类型语言是一旦变量的类型被确定，就不能转化的语言。 弱类型语言则反之，一个变量的类型是由其应用上下文确定的。 静态语言优势 由于类型的强制声明，使得IDE有很强的代码感知能力，故，在实现复杂的业务逻辑、开发大型商业系统、以及那些生命周期很长的应用中，依托IDE对系统的开发很有保障； 由于静态语言相对比较封闭，使得第三方开发包对代码的侵害性可以降到最低； 动态语言优势 思维不受束缚，可以任意发挥，把更多的精力放在产品本身上； 集中思考业务逻辑实现，思考过程即实现过程； 初识Python python以#开头的语句是注释，注释是给人看的，可以是任意内容，解释器会忽略掉注释。其他每一行都是一个语句，当语句以冒号:结尾时，缩进的语句视为代码块。 Python程序是大小写敏感的，如果写错了大小写，程序会报错。 Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。~代表该列表。 | 元素个数 | len（~） || ——————————————- | ——————— || 获取最后一个元素 | ~[-1] 或者~[len(~)-1] || 往list中追加元素到末尾 | ~.append(‘Reality’) || 元素插入到指定的位置，比如索引号为1的位置 | ~.insert(1,’brother’) || 删除list末尾的元素 | ~.pop() || 删除指定位置（索引号为1）的元素 | ~.pop(1) || 把某个元素替换成别的元素 | ~[0]=’Reality’ | 另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改。例如： classmates = (‘Michael’, ‘Bob’, ‘Tracy’) 😊注意：要定义一个只有1个元素的tuple，如果你这么定义：t = (1)定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，只有1个元素的tuple定义时必须加一个逗号,，来消除歧义：t = (1,) 在Python条件判断中elif是else if的缩写，例如： 1234if x: print('True')elif x&gt;=6: print('false') 只要x是非零数值、非空字符串、非空list等，就判断为True，否则为False。 input()返回的数据类型是str如需获取int类型则需要 int(~)进行转换为整数 Python中的循环有俩种一种是for…in循环，依次把list或tuple中的每个元素迭代出来，看例子： 1234sum = 0for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]: sum = sum + xprint(sum) 如果要计算1-100的整数之和，从1写到100有点困难，幸好Python提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为list。比如range(5)生成的序列是从0开始小于5的整数： 12&gt;&gt;&gt; list(range(5))[0, 1, 2, 3, 4] 第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环。 Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。用Python写一个dict如下： 123&gt;&gt;&gt; d = &#123;'Michael': 95, 'Bob': 75, 'Tracy': 85&#125;&gt;&gt;&gt; d['Michael']95 避免key不存在的错误，有两种办法，一是通过in判断key是否存在： 12&gt;&gt;&gt; 'Thomas' in dFalse 二是通过dict提供的get()方法，如果key不存在，可以返回None，或者自己指定的value： 123&gt;&gt;&gt; d.get('Thomas')&gt;&gt;&gt; d.get('Thomas', -1)-1 和list比较，dict有以下几个特点： 查找和插入的速度极快，不会随着key的增加而变慢； 需要占用大量的内存，内存浪费多。 而list相反： 查找和插入的时间随着元素的增加而增加； 占用空间小，浪费内存很少。 所以，dict是用空间来换取时间的一种方法。dict可以用在需要高速查找的很多地方。 set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key，重复元素自动被自动过滤。 | 添加元素到set中 | add(~) || ————— | ——— || 删除元素 | remove(~) | 在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。 定义默认参数要牢记一点：默认参数必须指向不变对象！ 123456def power(x, n=2): s = 1 while n &gt; 0: n = n - 1 s = s * x return s 定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。 12345def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sum 如果已经有一个list或者tuple，要调用一个可变参数怎么办？可以这样做： 123&gt;&gt;&gt; nums = [1, 2, 3]&gt;&gt;&gt; calc(*nums)14 *nums表示把nums这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。 使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个*作为特殊分隔符。如果缺少*，Python解释器将无法识别位置参数和命名关键字参数： 123456def person(name, age, *, city='Beijing', job): print(name, age, city, job) ------------------------------------------------------&gt;&gt;&gt; person('Jack', 24, job='Engineer')Jack 24 Beijing Engineer 在Python中定义函数时可以进行参数组合，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。 Python提供了切片（Slice）操作符来获取list或tuple中的前N个元素：~[0,N] 如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断： 1234567&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance('abc', Iterable) # str是否可迭代True&gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代True&gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代False 如果要对list实现类似Java那样的下标循环怎么办？Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身： 123456&gt;&gt;&gt; for i, value in enumerate(['A', 'B', 'C']):... print(i, value)...0 A1 B2 C Python支持在不创建完整的list的情况下一边循环一边计算，这样的机制称为生成器：generator，建一个generator，只要把一个列表生成式的[]改成()，就创建了一个generator，可以通过next()函数获得generator的下一个返回值： 12345&gt;&gt;&gt; g = (x * x for x in range(10))&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;&gt;&gt;&gt; next(g)0 可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。生成器都是Iterator对象，但list、dict、str虽然是Iterable(可迭代对象)，却不是Iterator。把list、dict、str等Iterable变成Iterator可以使用iter()函数：iter(&#39;abc&#39;)。 因为Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。 Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。 reduce的用法：reduce把一个函数作用在一个序列[x1,x2,x3,x4,...]上，这个函数必须接受俩个参数，reduce把结果继续和序列的下一个元素做累计运算： 1reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4) Python内建的filter()函数用于过滤序列。和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。例如，在一个list中，删掉偶数，只保留奇数，可以这么写： 12345def is_odd(n): return n % 2 == 1list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))# 结果: [1, 5, 9, 15] 返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。 在Python中，对匿名函数提供了有限支持。还是以map()函数为例，计算f(x)=x2时，除了定义一个f(x)的函数外，还可以直接传入匿名函数： 12&gt;&gt;&gt; list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))[1, 4, 9, 16, 25, 36, 49, 64, 81] 在Python中，定义类是通过class关键字，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的。 12class Student(object): pass 在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问 特殊方法”__init__“前后分别有两个下划线！！！也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用__name__、__score__这样的变量名。 对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了。 Python中允许给实例绑定一个没有在class中定义的属性或方法，但是我们想要挟制实例的属性时，就需要定义一个特殊的__slots__变量，来限制该class实例能添加的属性 12class Student(object): __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称 Python中的多进程 启动一个进程并等待其结束，multiprocessing模块提供了一个Process类来代表一个进程对象。 123456789101112# 启动一个子进程并等待其结束def run_proc(name): print('Run child process %s (%s)...' % (name, os.getpid()))if __name__ == '__main__': print('Parent Process %s.' % os.getpid()) p = Process(target=run_proc, args=('test',)) print('Child process will start') p.start() p.join() print('Child process end.') 其中join()方法用于等待子进程结束在继续往下执行 创建进程池，批量创建子进程 1234567891011121314151617def long_time_task(name): print('Run task %s (%s)...' % (name, os.getpid())) start = time.time() time.sleep(random.random() * 3) end = time.time() print('Task %s run %0.2f seconds.' % (name, (end - start)))if __name__ == '__main__': print('Parent process %0.2f seconds.' % os.getpid()) p = Pool(4) for i in range(5): p.apply_async(long_time_task, args=(i,)) print('Waiting for all subprocess done ...') p.close() p.join() print('All subprocess done') 这里我虽然创建的进程池数量为4，所以想要创建第五个子进程时需要等待前面某个任务结束才可以执行，所以执行效果如下： 12345678910111213Parent process 32496.00 seconds.Waiting for all subprocess done ...Run task 0 (19432)...Run task 1 (42996)...Run task 2 (52964)...Run task 3 (54000)...Task 3 run 1.35 seconds. #Task 3 执行完毕，空出进程Run task 4 (54000)... #Task 4 执行Task 2 run 1.44 seconds.Task 1 run 1.75 seconds.Task 0 run 2.54 seconds.Task 4 run 1.60 seconds.All subprocess done 如果不指定进程数将默认大小为主机的CPU核数。 进程间的通信 Pthon中的multiprocessing模块包装了可以实现进程通信的底层机制，提供了Queue、Pipes等多种方式来交换数据。 1234567891011121314151617181920212223242526# # 进程间的通信def write(q): print('Process to write: %s' % os.getpid()) for value in ['A', 'B', 'C']: print('Put %s to queue...' % value) q.put(value) time.sleep(random.random())def read(q): print('Process to read: %s' % os.getpid()) while True: value = q.get(True) print('Get %s from queue.' % value)if __name__ == '__main__': # 父进程创建Queue，并传递给各个子进程 q = Queue() pw = Process(target=write, args=(q,)) pr = Process(target=read, args=(q,)) # 启动子进程 pw.start() pr.start() pw.join() pr.terminate() 这里的程序运行之后会发现我们是在父进程中创建两个子进程，一个往Queue里写数据，一个从Queue里读数据，这样就实现了进程间的通信。 IO编程读写文件是最常见的IO操作。Python内置了读写文件的函数，用法和C是兼容的。 读文件 使用Python内置的open()函数，传入文件名与标识符r 12345678910# 普通捕获IOError读文件try: f = open('C:/Users/sujunqiang/Desktop/入职邮件.txt', 'r') print(f.read())finally: if f: f.close()# with语句读取二进制文件with open('C:/Users/sujunqiang/Desktop/硬件/蓝信图片_0880c08b0110dcb4d408.jpg', 'rb') as f1: print(f1.read()) 由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们要捕获他的异常和最终执行f.close()；Python引入了with语句来自动帮我们调用close()方法。 写文件 写文件与读文件是一样的只是标识符改为了w如果想在文件后面追加内容则标识符为a 123# with语句写文件 with open('C:/Users/sujunqiang/Desktop/入职邮件.txt', 'a') as f2: f2.write('测试写入') StringIO和BytesIO StringIO 很多时候，数据读写不一定是文件，也可以在内存中读写。StringIO顾名思义就是在内存中读写str。要把str写入StringIO，我们需要先创建一个StringIO，然后，像文件一样写入即可。 123456789f = StringIO() f.write('Hello StringIO') print(f.getvalue()) f1 = StringIO('Hello \n Hi \n 你好') while True: s = f1.readline() if s == '': break print(s.strip()) 其中getvalue()方法用于获得写入后的str，write()写入数据，也可以直接初始化StringIO， f1 = StringIO(&#39;Hello \n Hi \n 你好&#39;) BytesIO StringIO操作的只能是str，如果要操作二进制数据，就需要使用BytesIO。 123f3 = BytesIO('中文'.encode('utf-8')) # f3.write('中文'.encode('utf-8')) print(f3.getvalue()) Python的异步IOPython对协程的支持是通过generator实现的。 在generator中，我们不但可以通过for循环来迭代，还可以不断调用next()函数获取由yield语句返回的下一个值。 但是Python的yield不但可以返回一个值，它还可以接收调用者发出的参数。 1234567891011121314151617181920212223def consumer(): r = '' while True: n = yield r if not n: return print('[CONSUMER] Consuming %s ...' % n) r = '200 OK'def produce(c): c.send(None) n = 0 while n &lt; 5: n = n + 1 print('[PRODUCER] Producing %s...' % (n)) r = c.send(n) print('[PRODUCER] Consumer return: %s' % r) c.close()c = consumer()produce(c) 注意到consumer函数是一个generator，把一个consumer传入produce后： 首先调用c.send(None)启动生成器； 然后，一旦生产了东西，通过c.send(n)切换到consumer执行； consumer通过yield拿到消息，处理，又通过yield把结果传回； produce拿到consumer处理的结果，继续生产下一条消息； produce决定不生产了，通过c.close()关闭consumer，整个过程结束。 asyncio asyncio的编程模型就是一个消息循环。我们从asyncio模块中直接获取一个EventLoop的引用，然后把需要执行的协程扔到EventLoop中执行，就实现了异步IO。 1234567891011121314151617import asyncioimport threading@asyncio.coroutinedef hello(): print('Hello world! (%s)' % threading.currentThread()) yield from asyncio.sleep(1) print('Hello again! (%s)' % threading.currentThread())# 获取EventLoop:loop = asyncio.get_event_loop()tasks = [hello(), hello()]# 执行coroutineloop.run_until_complete(asyncio.wait(tasks))loop.close() 输出： 12345Hello world! (&lt;_MainThread(MainThread, started 61596)&gt;)Hello world! (&lt;_MainThread(MainThread, started 61596)&gt;)# 暂停1秒Hello again! (&lt;_MainThread(MainThread, started 61596)&gt;)Hello again! (&lt;_MainThread(MainThread, started 61596)&gt;) 由打印的当前线程名称可以看出，两个coroutine是由同一个线程并发执行的。第一个hello()会首先打印出Hello world!，然后，yield from语法可以让我们方便地调用另一个generator。由于asyncio.sleep()也是一个coroutine，所以线程不会等待asyncio.sleep()，而是直接中断并执行下一个消息循环。当asyncio.sleep()返回时，线程就可以从yield from拿到返回值（此处是None），然后接着执行下一行语句。 把asyncio.sleep(1)看成是一个耗时1秒的IO操作，在此期间，主线程并未等待，而是去执行EventLoop中另一个可以执行的coroutine了，因此可以实现并发执行。 async/await 用asyncio提供的`@asyncio.coroutine可以把一个generator标记为coroutine类型，然后在coroutine内部用yield from`调用另一个coroutine实现异步操作。 为了简化并更好地标识异步IO，从Python 3.5开始引入了新的语法async和await，async和await是针对coroutine的新语法，要使用新的语法，只需要做两步简单的替换： 把`@asyncio.coroutine替换为async`； 把yield from替换为await。 12345678910111213141516import asyncioimport threadingasync def hello(): print('Hello world! (%s)' % threading.currentThread()) await asyncio.sleep(1) print('Hello again! (%s)' % threading.currentThread())# 获取EventLoop:loop = asyncio.get_event_loop()tasks = [hello(), hello()]# 执行coroutineloop.run_until_complete(asyncio.wait(tasks))loop.close()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPXE环境Docker化]]></title>
    <url>%2F2020%2F08%2F25%2FIPXE%E7%8E%AF%E5%A2%83Docker%E5%8C%96%2F</url>
    <content type="text"><![CDATA[IPXE环境Docker化初识Docker1.安装Docker这里的宿主机环境为CentOS7.5 卸载旧版本 12345678910$ yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-selinux \ docker-engine-selinux \ docker-engine 执行以下命令安装依赖包 123$ yum install -y yum-utils \ device-mapper-persistent-data \ lvm2 下面的命令添加 yum 软件源 12345678910$ sudo yum-config-manager \ --add-repo \ https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo$ sudo sed -i 's/download.docker.com/mirrors.ustc.edu.cn\/docker-ce/g' /etc/yum.repos.d/docker-ce.repo# 官方源# $ sudo yum-config-manager \# --add-repo \# https://download.docker.com/linux/centos/docker-ce.repo 更新 yum 软件源缓存，并安装 docker-ce 12$ sudo yum makecache fast$ sudo yum install docker-ce 启动 Docker CE 12$ sudo systemctl enable docker$ sudo systemctl start docker 建立 docker 用户组 1234#建立 docker 组：$ sudo groupadd docker#将当前用户加入 docker 组：$ sudo usermod -aG docker $USER 测试 Docker 是否安装正确 123456789101112131415161718192021222324252627[root@localhost ~]# docker run hello-worldUnable to find image 'hello-world:latest' locallylatest: Pulling from library/hello-world0e03bdcc26d7: Pull complete Digest: sha256:7f0a9f93b4aa3022c3a4c147a449bf11e0941a1fd0bf4a8e6c9408b2600777c5Status: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the "hello-world" image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/get-started/ 2.获取镜像 通过以下命令获取版本信息 12[root@localhost ~]# cat /etc/redhat-release CentOS Linux release 7.5.1804 (Core) 从 Docker 镜像仓库获取镜像 123456[root@localhost ~]# docker pull centos:7.5.18047.5.1804: Pulling from library/centos5ad559c5ae16: Pull complete Digest: sha256:7a45e4a1efbaafc1d9aa89925b6fdb33288a96d35ea0581412316e2f0ad3720aStatus: Downloaded newer image for centos:7.5.1804docker.io/library/centos:7.5.1804 以这个镜像为基础运行一个容器 12345678910111213141516171819# 运行容器[root@localhost home]# docker run -it --rm centos:7.5.1804 bash#查看当前系统版本[root@a64f538e2e9a /]# cat /etc/os-releaseNAME="CentOS Linux"VERSION="7 (Core)"ID="centos"ID_LIKE="rhel fedora"VERSION_ID="7"PRETTY_NAME="CentOS Linux 7 (Core)"ANSI_COLOR="0;31"CPE_NAME="cpe:/o:centos:centos:7"HOME_URL="https://www.centos.org/"BUG_REPORT_URL="https://bugs.centos.org/"CENTOS_MANTISBT_PROJECT="CentOS-7"CENTOS_MANTISBT_PROJECT_VERSION="7"REDHAT_SUPPORT_PRODUCT="centos"REDHAT_SUPPORT_PRODUCT_VERSION="7" -it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。 --rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 --rm 可以避免浪费空间。 centos:7.5.1804：这是指用 centos:7.5.1804 镜像为基础来启动容器。 bash：放在镜像名后的是 命令，这里我们希望有个交互式 Shell，因此用的是 bash。 查看镜像列表 1234[root@localhost home]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEhello-world latest bf756fb1ae65 7 months ago 13.3kBcentos 7.5.1804 cf49811e3cdb 17 months ago 200MB 删除镜像 123456789101112131415161718#首先，删除容器名称[root@localhost home]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES2258ea78efdb hello-world "/hello" 36 minutes ago Exited (0) 36 minutes ago intelligent_kare[root@localhost home]# docker rm intelligent_kareintelligent_kare[root@localhost home]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES[root@localhost home]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEhello-world latest bf756fb1ae65 7 months ago 13.3kBcentos 7.5.1804 cf49811e3cdb 17 months ago 200MB#其次，取出容器[root@localhost home]# docker rmi hello-worldUntagged: hello-world:latestUntagged: hello-world@sha256:7f0a9f93b4aa3022c3a4c147a449bf11e0941a1fd0bf4a8e6c9408b2600777c5Deleted: sha256:bf756fb1ae65adf866bd8c456593cd24beb6a0a061dedf42b26a993176745f6bDeleted: sha256:9c27e219663c25e0f28493790cc0b88bc973ba3b1686355f221c38a36978ac63 在docker中使用systemctl来管理服务 1234567# 尝试这样启动容器–-privileged=true参数，表示容器拥有root权限[root@localhost ~]# docker run -it --privileged centos-ipxe:v1 /usr/sbin/init# 这样进入容器的bash[root@localhost ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES91c2387e0241 centos-ipxe:v1 "/usr/sbin/init" 24 seconds ago Up 24 seconds affectionate_solomon[root@localhost ~]# docker exec -i -t 91c2387e0241 bash 操作容器 列出所有的容器 ID 1docker ps -aq 停止所有的容器 1docker stop $(docker ps -aq) 删除所有的容器 1docker rm $(docker ps -aq) 删除所有的镜像 1docker rmi $(docker images -q) 复制文件 12docker cp mycontainer:/opt/file.txt /opt/local/docker cp /opt/local/file.txt mycontainer:/opt/ 查看docker启动失败的日志 1docker logs ae2a84920946 DockerFile定制镜像1.DockerFile常用指令详解 FROM 指定基础镜像 所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 nginx 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 FROM 就是指定 基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。 12From centos:7.5.1804...... RUN 执行命令 RUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种： shell 格式：RUN &lt;命令&gt;，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 RUN 指令就是这种格式。 1RUN yum install -y ipxe-bootimgs dnsmasq --nogpgcheck exec 格式：RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]，这更像是函数调用中的格式。 123456RUN yum install -y xinetd tftp-server tftp ipxe-bootimgs --nogpgcheck \ &amp;&amp; mkdir /var/lib/tftpboot/images \ &amp;&amp; cp /usr/share/ipxe/undionly.kpxe /var/lib/tftpboot/ \ &amp;&amp; cp /usr/share/ipxe/ipxe.efi /var/lib/tftpboot/ \ &amp;&amp; mkdir /var/lib/tftpboot/menu \ &amp;&amp; touch /var/lib/tftpboot/menu/boot.ipxe COPY复制文件 格式COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt; 1COPY ./start.sh /root/ ADD更高级的复制文件 ADD 指令和 COPY 的格式和性质基本一致。但是在 COPY 基础上增加了一些功能。比如 &lt;源路径&gt; 可以是一个 URL，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 &lt;目标路径&gt; 去。如果 &lt;源路径&gt; 为一个 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，ADD 指令将会自动解压缩这个压缩文件到 &lt;目标路径&gt; 去。 1ADD --chown=55:mygroup files* /mydir/ 因此在 COPY 和 ADD 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 COPY 指令，仅在需要自动解压缩的场合使用 ADD。 CMD 容器启动命令 CMD 指令的格式和 CRUN 相似，也是两种格式： shell 格式：CMD &lt;命令&gt; exec 格式：CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...] 1CMD service nginx start ENTRYPOINT 入口点 ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。ENTRYPOINT 在运行时也可以替代，不过比 CMD 要略显繁琐，需要通过 docker run 的参数 --entrypoint 来指定。 当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令，换句话说实际执行时，将变为： 1&lt;ENTRYPOINT&gt; "&lt;CMD&gt;" ENV 设置环境变量 格式有两种： ENV &lt;key&gt; &lt;value&gt; ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;... 定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 node 镜像 Dockerfile 中，就有类似这样的代码： 123456789ENV NODE_VERSION 7.2.0RUN curl -SLO "https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz" \ &amp;&amp; curl -SLO "https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc" \ &amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \ &amp;&amp; grep " node-v$NODE_VERSION-linux-x64.tar.xz\$" SHASUMS256.txt | sha256sum -c - \ &amp;&amp; tar -xJf "node-v$NODE_VERSION-linux-x64.tar.xz" -C /usr/local --strip-components=1 \ &amp;&amp; rm "node-v$NODE_VERSION-linux-x64.tar.xz" SHASUMS256.txt.asc SHASUMS256.txt \ &amp;&amp; ln -s /usr/local/bin/node /usr/local/bin/nodejs ARG 构建参数 格式：ARG &lt;参数名&gt;[=&lt;默认值&gt;] 构建参数和 ENV 的效果一样，都是设置环境变量。所不同的是，ARG 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 ARG 保存密码之类的信息，因为 docker history 还是可以看到所有值的。 EXPOSE 暴露端口 格式为 EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]。 EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。 WORKDIR 指定工作目录 格式为 WORKDIR &lt;工作目录路径&gt;。 使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。 USER 指定当前用户 格式：USER &lt;用户名&gt;[:&lt;用户组&gt;] USER 指令和 WORKDIR 相似，都是改变环境状态并影响以后的层。WORKDIR 是改变工作目录，USER 则是改变之后层的执行 RUN, CMD 以及 ENTRYPOINT 这类命令的身份。 2.构建镜像我们使用了docker build 命令进行镜像构建。其格式为： 123docker build [选项] &lt;上下文路径/URL/-&gt;####################举例###########################docker build -t ipxe-server:v1 . 如果注意，会看到 docker build 命令最后有一个 .。. 表示当前目录，而 Dockerfile 就在当前目录，因此不少初学者以为这个路径是在指定 Dockerfile 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定 上下文路径。 一般来说，应该会将 Dockerfile 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 .gitignore 一样的语法写一个 .dockerignore，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。 那么为什么会有人误以为 . 是指定 Dockerfile 所在目录呢？这是因为在默认情况下，如果不额外指定 Dockerfile 的话，会将上下文目录下的名为 Dockerfile 的文件作为 Dockerfile。 这只是默认行为，实际上 Dockerfile 的文件名并不要求必须为 Dockerfile，而且并不要求必须位于上下文目录中，比如可以用 -f ../Dockerfile.php 参数指定某个文件作为 Dockerfile。 当然，一般大家习惯性的会使用默认的文件名 Dockerfile，以及会将其置于镜像构建上下文目录中。 3.运行镜像docker run ：创建一个新的容器并运行一个命令 语法 1docker run [OPTIONS] IMAGE [COMMAND] [ARG...] OPTIONS说明： -a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项； -d: 后台运行容器，并返回容器ID； -i: 以交互模式运行容器，通常与 -t 同时使用； -P: 随机端口映射，容器内部端口随机映射到主机的端口 -p: 指定端口映射，格式为：主机(宿主)端口:容器端口 -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用； –name=”nginx-lb”: 为容器指定一个名称； –dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致； –dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致； -h “mars”: 指定容器的hostname； -e username=”ritchie”: 设置环境变量； –env-file=[]: 从指定文件读入环境变量； –cpuset=”0-2” or –cpuset=”0,1,2”: 绑定容器到指定CPU运行； -m : 设置容器使用内存最大值； –net=”bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型； –link=[]: 添加链接到另一个容器； –expose=[]: 开放一个端口或一组端口； –volume , -v: 绑定一个卷 –restart=always 在容器已经stop掉或Docker stoped/restarted的时候重启容器 –privileged=true 使用该参数container内的root拥有真正的root权限。 4.导入/导出镜像123456789####################导出########################[root@localhost ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESa0a7ceb5e3d8 ipxe-server:v1 "/bin/bash -c /root/…" 14 hours ago Up 14 hours ipxe-server[root@localhost ~]# docker export a0a7ceb5e3d8 &gt; ipxe.tar####################导入#########################cat ipxe.tar | docker import - ipxe-server:v1 IPXE环境DOCKER化创建文件夹/docker-image-file/ipxe-docker并在其中创建DockerFile`start.shdocker_build.shdocker_start.sh`脚本 123mkdir -p /root/docker-image-file/ipxe-dockercd /root/docker-image-file/ipxe-dockertouch Dockerfile start.sh docker_build.sh docker_start.sh 1.编写DockerFile1234567891011121314151617181920212223From centos:7.5.1804MAINTAINER “Reality” &lt;809962111@qq.com&gt;ENV container docker# 配置dnsmasq服务包含dhcp、tftp#RUN yum install -y ipxe-bootimgs dnsmasq --nogpgcheck \# &amp;&amp; mkdir -p /tftpboot/images \# &amp;&amp; mkdir /tftpboot/menu \# 安装TFTP服务RUN yum install -y xinetd tftp-server tftp ipxe-bootimgs --nogpgcheck \ &amp;&amp; mkdir /var/lib/tftpboot/images \# &amp;&amp; cp /usr/share/ipxe/undionly.kpxe /var/lib/tftpboot/ \# &amp;&amp; cp /usr/share/ipxe/ipxe.efi /var/lib/tftpboot/ \ &amp;&amp; mkdir /var/lib/tftpboot/menu \# &amp;&amp; touch /var/lib/tftpboot/menu/boot.ipxe \# 安装DHCP服务 &amp;&amp; yum -y install dhcp --nogpgcheck \# 安装ftp服务 &amp;&amp; yum -y install vsftpd --nogpgcheck \ &amp;&amp; mkdir /var/ftp/pub/ipxe# 安装HTTPD# &amp;&amp; yum -y install httpd --nogpgcheck# 添加start.sh脚本COPY ./start.sh /root/ 2.编写start.sh1234567891011121314151617181920212223242526272829303132333435#!/bin/bashchk() &#123; if [ $1 != 0 ] then echo $2 exit 1 fi&#125;# 开启dnsmasq服务#pkill dnsmasq &gt; /dev/null 2&gt;&amp;1#rm -f /run/dnsmasq.pid#/usr/sbin/dnsmasq# 开启vsftpd服务pkill vsftpd &gt; /dev/null 2&gt;&amp;1/usr/sbin/vsftpdchk $? "vsftpd error,exit."# 开启dhcp服务pkill dhcpd &gt; /dev/null 2&gt;&amp;1/usr/sbin/dhcpd -cf /etc/dhcp/dhcpd.conf --no-pidchk $? "dhcpd error,exit."# 开启xinetd(tftp)服务rm -f /run/xinetd.pid/usr/sbin/xinetd -stayalive -pidfile /var/run/xinetd.pidchk $? "xinetdd error,exit."# 开启HTTPD服务#pkill httpd &gt; /dev/null 2&gt;&amp;1#rm -rf /run/httpd/*#/usr/sbin/apachectl#chk $? "apache error,exit." 3.编写docker_build.sh123#!/bin/bash# Dockerfile 构建ipxe环境docker build -t ipxe-server:v1 . 4.编写docker_start.sh12345678910111213141516171819202122232425262728293031323334353637383940414243444546#!/bin/bashCONTAINER_NAME="ipxe-server"# 文件路径及配置映射HOST_TFTP_TFTPBOOT_DIR="/root/docker-image-file/ipxe/tftp/tftpboot"DOCKER_TFTP_TFTPBOOT_DIR="/var/lib/tftpboot"HOST_FTP_IMAGE_DIR="/root/docker-image-file/ipxe/ftp/ipxe"DOCKER_FTP_IMAGE_DIR="/var/ftp"#HOST_HTTPD_DIR="/root/docker-image-file/ipxe/tftp/tftpboot/images"#DOCKER_HTTPD_DIR="/var/www/html"HOST_DHCP_CONF_FILE="/root/docker-image-file/ipxe/dhcp/dhcpd.conf"DOCKER_DHCP_CONF_FILE="/etc/dhcp/dhcpd.conf"HOST_TFTP_CONF_FILE="/root/docker-image-file/ipxe/tftp/tftp"DOCKER_TFTP_CONF_FILE="/etc/xinetd.d/tftp"# 启动dockerIMAGE_ID=$(docker run -it --net=host -d --name $&#123;CONTAINER_NAME&#125; \ -v $&#123;HOST_TFTP_TFTPBOOT_DIR&#125;:$&#123;DOCKER_TFTP_TFTPBOOT_DIR&#125; \ -v $&#123;HOST_FTP_IMAGE_DIR&#125;:$&#123;DOCKER_FTP_IMAGE_DIR&#125; \ -v $&#123;HOST_DHCP_CONF_FILE&#125;:$&#123;DOCKER_DHCP_CONF_FILE&#125; \ -v $&#123;HOST_TFTP_CONF_FILE&#125;:$&#123;DOCKER_TFTP_CONF_FILE&#125; \ --privileged=true --restart=always ipxe-server:v1 /bin/bash -c "/root/start.sh;/bin/bash")[[ $? -ne 0 ]] &amp;&amp; echo "Start ipxe server container failed" &amp;&amp; exit 1sleep 0.1s # 进入容器bashecho "CONTAINER ID IS : $IMAGE_ID"read -p "Type y/n to enter bash or exit: " enter_message #提示用户输入数字echo "$enter_message" | grep -q "y"if [ $? -eq 0 ] then #判断用户是否输入y echo "&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;bash&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;" docker exec -it "$IMAGE_ID" bash exitelse exitfiexit 0]]></content>
      <categories>
        <category>IPXE</category>
      </categories>
      <tags>
        <tag>IPXE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPXE、PXE 环境 ？？？]]></title>
    <url>%2F2020%2F08%2F15%2FPXE%26IPXE%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[摘要在实际工作中，我们经常会遇到这样的情况：想要安装Linux但是计算机不带光驱或软驱，或者是笔记本配置的非标准的软驱和光驱，如USB接口，在Linux安装时所引导的Linux内核一般都不会带这些接口的驱动，所以也无法通过本地安装Linux，此外，在一些场合，如机房，IT实验室，工厂生产线，有大量的计算机需要同时安装Linux，如果通过光驱的方式一个个安装，不仅效率低，也不利于维护。这是时候你就需要PXE的强大功能了，本文将会介绍PXE、IPXE、网络引导交互过程以及配置流程。 PXEPXE是指在没有软驱、硬盘、CD-ROM的情况下引导计算机的一种方式，也就是BIOS将使用PXE协议从网络引导。 DHCP服务器：用来动态分配IP地址（同时分配子网掩码、网关、TFTP服务器地址、启动文件名、DNS服务器、时间服务器等等）。 TFTP服务器：用来提供启动文件的下载 简单说来，PXE服务器就是DHCP服务器+TFTP服务器。工作于Client/Server的网络模式，支持工作站通过网络从远端服务器下载映像，并由此支持通过网络启动操作系统，在启动过程中，终端要求DHCP服务器分配IP地址，再用TFTP（trivial file transfer protocol）或MTFTP(multicast trivial file transfer protocol)协议下载一个启动软件包到本机内存中执行，由这个启动软件包完成终端（客户端）基本软件设置，从而引导预先安装在服务器中的终端操作系统。PXE可以引导多种操作系统，如：Windows95/98/2000/windows2003/windows2008/winXP/win7/win8,linux系列系统等。 IPXEipxe的前身为gpxe，由于gPXE存在商业收购风险。其开发者又启动了一个名为iPXE的开源项目。作为gPXE的一个分支。 官方地址：http://ipxe.org/从官网文档中可以看出，ipxe很强大，也确实强大。大致意思是pxe进化gpxe，gpxe进化ipxe（http://ipxe.org/faq）。支持更多的协议，兼容性更好，不挑网卡。不过也可以给网卡刷一下rom，让网卡更好的支持ipxe启动（http://ipxe.org/howto/romburning）。它提供了完整的PXE实施，并增强了其他功能，例如： 通过HTTP从Web服务器启动 从iSCSI SAN引导 通过FCoE从光纤通道SAN引导 从AoE SAN引导 从无线网络启动 从广域网启动 从Infiniband网络启动 用脚本控制引导过程 BIOS和UEFIBIOS： （Basic Input/Output System的缩写、中文：基本输入输出系统），在IBM PC兼容机上，是一种业界标准的固件接口。BIOS这个字眼是在1975第一次由CP/M操作系统中出现。BIOS是个人电脑启动时加载的第一个软件。BIOS用于计算机开机时执行系统各部分的的自检，并启动引导程序或装载在内存的操作系统。此外，BIOS还向操作系统提供一些系统参数。系统硬件的变化是由BIOS隐藏，程序使用BIOS服务而不是直接访问硬件。现代操作系统会忽略BIOS提供的抽象层并直接访问硬件组件。 每一台普通的电脑都会有一个BIOS，用于加载电脑最基本的程式码，担负着初始化硬件，检测硬件功能以及引导操作系统的任务。 UEFI： 全称“统一的可扩展固件接口”(Unified Extensible Firmware Interface)，是一种详细描述类型接口的标准。这种接口用于操作系统自动从预启动操作环境，加载到一种操作系统上。可扩展固件接口（Extensible Firmware Interface，EFI）是 Intel 为 PC 固件的体系结构、接口和服务提出的建议标准。其主要目的是为了提供一组在 OS 加载之前（启动前）在所有平台上一致的、正确指定的启动服务，被看作是有近20多年历史的 BIOS 的继任者。另外，由于UEFI不支持32位。 UEFI的特点 来自微软官网 1、通过保护预启动或预引导进程，从而提高安全性。2、缩短了启动时间和从休眠状态恢复的时间。3、支持容量超过2.2 TB的驱动器。4、支持64位的现代固件设备驱动程序，系统在启动过程中可以使用它们来对超过172亿GB的内存进行寻址。5、UEFI硬件可与BIOS结合使用。 环境IPXE 对运行环境没有什么需求，只需能提供 tftp, dhcp, http 等服务的系统即可。这里使用 Linux 环境来搭建IPXE服务；采用 dnsmasq 这个小巧玲珑的软件提供 tftp 和 dhcp 服务；这里在虚拟机VMware® Workstation 15 Pro中预装了CentOS-7.5-x86_64-DVD-1804,以及将该镜像放置在/home/目录下，为后续空白虚拟机进行网卡启动安装系统做好准备。 DHCP服务:给客户端分配IP地址,定位引导程序 DNS服务:为客户端分配主机名(可选) TFTP服务:提供引导程序下载(因为网卡PXE只提供了TFTP客户端) FTP服务(或者HTTP/NFS):提供安装系统所需要的软件包(yum源) LINUX下的内核文件（vmlinuz/initrd.img/ System.map ）vmlinuzvmlinuz是可引导的、压缩的内核。“vm”代表“Virtual Memory”。Linux 支持虚拟内存，不像老的操作系统比如DOS有640KB内存的限制。Linux能够使用硬盘空间作为虚拟内存，因此得名“vm”。vmlinuz是可执行的Linux内核，它位于/boot/vmlinuz，它一般是一个软链接。vmlinux是未压缩的内核，vmlinuz是vmlinux的压缩文件。 作用：进程管理、内存管理、文件管理、驱动管理、网络管理。 initrd.imginitrd.img是一个小ramdisk(内存虚拟硬盘)的映象， 放的是和启动相关的驱动模块，用一部分内存模拟成磁盘，让操作系统访问。通常的步骤是先启动内核，然后内核挂载initrd.img，并执行里面的脚本来进一步挂载各种各样的模块。其中最重要的就是根文件系统驱动模块，有了它才能挂载根文件系统，继而运行用户空间的第一个应用程序，完成系统后续的启动。 启动流程大体流程：客户机从DHCP(获取IP，寻找iPXE服务器)&gt;tftp获取开机启动文件&gt;HTTP/TFTP/FTP（加载安装文件）&gt;本地安装 IPXE-CentOS7环境配置1.配置dnsmasq服务和ipxe基本环境本次预装CentOS的网络适配器选择的是VMnet8（NAT）模式，配置dnsmasq服务和ipxe基本环境安装需要的包： 1yum install -y ipxe-bootimgs dnsmasq 等待安装完毕后，创建目录 12345mkdir /tftpboot# 适用于 BIOS 硬件cp /usr/share/ipxe/undionly.kpxe /tftpboot/# 适用于 EFI 硬件cp /usr/share/ipxe/ipxe.efi /tftpboot/ 编写一个boot.ipxe文件，用来展示IPXE的引导界面 12mkdir /tftpboot/menuvi /tftpboot/menu/boot.ipxe 编写如下内容： 123456789101112#!ipxemenu PXE Boot Optionsitem shell iPXE shellitem exit Exit to BIOS# 默认选择 exit， 等待时间10schoose --default exit --timeout 10000 option &amp;&amp; goto $&#123;option&#125;# 可以切换到shell:shellshell# 退出:exitexit 修改/etc/dnsmasq.conf配置文件，更具自己实际情况配置 1234567891011121314151617181920212223# 禁用dnsport=0# 监听地址本机iplisten-address=192.168.249.131# 接听网口interface=ens33 # 启动tftpenable-tftp# 配置tftp存储文件的目录tftp-root=/tftpboot # 随机分配地址dhcp-range=192.168.249.200,192.168.249.250,255.255.255.0# 或者静态分配地址#dhcp-range=192.168.72.200,static,255.255.255.0 # 配置引导文件dhcp-vendorclass=BIOS,PXEClient:Arch:00000dhcp-match=set:ipxe,175dhcp-boot=tag:!ipxe,tag:BIOS,undionly.kpxedhcp-boot=tag:!ipxe,tag:!BIOS,ipxe.efidhcp-boot=tag:ipxe,menu/boot.ipxe 启动服务关闭Firewalls &amp; SELinux并重启 12345678# 开机不自动启动防火墙systemctl disable firewalld# 开机自动启动dnsmasqsystemctl enable dnsmasq# 通过修改SELINUX的配置文件达到关闭SELINUX服务(SELinux 主要作用就是最大限度地减小系统中服务进程可访问的资 # 源（最小权限原则）。)sed -i 's/SELINUX=enforcing/SELINUX=disabled/g' /etc/selinux/config# 重新启动reboot 2.设置CentOS7网络安装安装http服务并设置开机启动 12345yum -y install httpd# 开启httpd服务systemctl start httpd# 设置为开机自启动systemctl enable httpd 挂载iso到http服务上 123456# 创建一个目录用来挂载镜像mkdir /var/www/html/media/cd /var/www/html/media/mkdir centos7-ipxe# 挂在镜像到ipxe-iso目录下mount -t iso9660 -o,loop /home/CentOS-7.5.iso /var/www/html/media/centos7-ipxe/ 修改/tftpboot/menu/boot.ipxe如下 12345678910111213141516171819#!ipxe:startmenu PXE Boot Optionsitem shell iPXE shell# 创建CentOS 7 installation选项item centos7-net CentOS 7 installationitem exit Exit to BIOSchoose --default centos7-net --timeout 10000 option &amp;&amp; goto $&#123;option&#125;:shellshell:centos7-netset server_root http://192.168.249.131/media/centos7-ipxeinitrd $&#123;server_root&#125;/images/pxeboot/initrd.img# 这里没有使用ks文件,如果使用ks自动安装的情况# kernel $&#123;server_root&#125;/images/pxeboot/vmlinuz inst.ks=$&#123;server_root&#125;/centos7.ks ip=dhcp ipv6.disable initrd=initrd.imgkernel $&#123;server_root&#125;/images/pxeboot/vmlinuz inst.repo=$&#123;server_root&#125;/ ip=dhcp ipv6.disable initrd=initrd.img inst.geoloc=0 devfs=nomountboot:exitexit 3.网络安装CentOS新建虚拟机设置为稍后安装操作系统。注意：指定分配给虚拟机的内存需至少为2G以免安装错误 之后按照正常创建虚拟机的方式进行创建空白虚拟机，创建好后打开该虚拟机，看到如下画面说明你已成功一半了： 接下来等待数秒会进入如PXE的菜单选项选择 CenOS 7 installation进行安装 回车后等待进入安装画面 接下来按照提示正确安装即可 4.使用ks自动安装上述安装为手动选择并配置安装，下面讲述的是通过linux的自动安装脚本kickstart完成系统全自动安装。这里t通过kickstart配置工具system-config-kickstart生成脚本,创建文件 centos7.ks并键入一下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#version=DEVEL# Install OS instead of upgradeinstall# Keyboard layoutskeyboard 'us'# Root password=123456rootpw --iscrypted $1$jTvf.BHT$2x/yp/PYMZcRmD6/kCrGi1# Use network installationurl --url="http://192.168.249.131/media/centos7-ipxe"# System languagelang zh_CN# System authorization informationauth --useshadow --passalgo=sha512# 命令行 Use text mode install# text# 图形化 Use graphical installgraphicalfirstboot --disable# SELinux configurationselinux --disabled# Firewall configurationfirewall --disabled# Network informationnetwork --bootproto=dhcp --device=ens33# Reboot after installationreboot# System timezonetimezone Asia/Shanghai# username=admin password=123456 user --name=admin --password=$6$piKcV2Fc3Qn6nHdr$a7jafMHWefFMfiNGGb4USIuEXSTlJur5D.DXwFOLHaita35p6DgJwXtBgqjXK/5/5RAghsmNADw1v07bj8jAx1 --iscrypted --gecos="admin"# System bootloader configurationbootloader --location=mbr# Clear the Master Boot Recordzerombr# Partition clearing informationclearpart --all --initlabel# Disk partitioning informationpart /boot --fstype="xfs" --size=500part /home --fstype="xfs" --size=4096part swap --fstype="swap" --size=4096part / --fstype="xfs" --grow --size=1%packages@base@core@desktop-debugging@dial-up@directory-client@fonts@gnome-desktop@guest-desktop-agents@input-methods@internet-browser@java-platform@multimedia@network-file-system-client@print-client@x11binutilschronyftpgcckernel-develkexec-toolsmakeopen-vm-toolspatchpython%end%addon com_redhat_kdump --enable --reserve-mb='auto'%end 将该文件移动至/var/www/html/media下，由于/var/www/html/media/centos7-ipxe/下已挂在CentOS的镜像，不允许被写入，所以我们修改/tftpboot/menu/boot.ipxe 123456789101112131415161718#!ipxe:startmenu PXE Boot Optionsitem shell iPXE shellitem centos7-net CentOS 7 installationitem exit Exit to BIOSchoose --default centos7-net --timeout 10000 option &amp;&amp; goto $&#123;option&#125;:shellshell:centos7-netset server_root http://192.168.249.131/media/centos7-ipxeinitrd $&#123;server_root&#125;/images/pxeboot/initrd.img# 这里使用ks自动安装kernel $&#123;server_root&#125;/images/pxeboot/vmlinuz inst.ks=http://192.168.249.131/media/centos7.ks ip=dhcp ipv6.disable initrd=initrd.img#kernel $&#123;server_root&#125;/images/pxeboot/vmlinuz inst.repo=$&#123;server_root&#125;/ ip=dhcp ipv6.disable initrd=initrd.img inst.geoloc=0 devfs=nomountboot:exitexit 这样我们新建一台空白虚拟机启动虚拟机，在同一网段下就可以实现无人值守全自动安装CentOS7。 5.补充还有一些命令需要了解一下，就是网卡启动的时候Ctrl-B出来的界面。 1.查看网卡设备： 123iPXE&gt; ifstatnet0: 52:54:00:12:34:56 using rtl8139 on PCI00:03.0 (closed) [Link:up, TX:0 TXE:0 RX:0 RXE:0] 2.dhcp获取ip： 12iPXE&gt; dhcpDHCP (net0 52:54:00:12:34:56).... ok 3.查看目前获取到的IP和DNS： 1234iPXE&gt; routenet0: 10.0.0.155/255.255.255.0 gw 10.0.0.1iPXE&gt; show dnsnet0.dhcp/dns:ipv4 = 10.0.0.6 4.直接链到“default”文件： 1iPXE&gt; chain http://boot.ipxe.org/demo/boot.php PXE-CentOS7环境配置pxe环境配置同样需要有一个DHCP服务器，需要有tftp服务器和一个文件服务器，其中文件服务器可以是ftp，http，nfs等文件服务器，这里我们以tftp、dhcp、ftp(vsftpd)服务进行搭建 1.安装tftp服务tftp的服务器需要安装tftp-server包，在CentOS7需要启动tftpd.socket ，其中tftp默认的文件路径为/var/lib/tftpboot，接下来进行tftp-server安装： 1yum -y install tftp-server tftp 启动tftp服务 1systemctl start tftp.socket 修改默认根文件路径 12345678910111213141516[root@centos7 ~]#vim /etc/xinetd.d/tftp############################配置详情#########################service tftp&#123; socket_type = dgram protocol = udp wait = yes user = root server = /usr/sbin/in.tftpd #修改文件目录为根文件 server_args = -s /var/lib/tftpboot -c disable = yes per_source = 11 cps = 100 2 flags = IPv4&#125; tftp客户端测试 123456789[root@centos7 ~]#yum -y install tftp[root@centos7 ~]#cd /var/lib/tftpboot[root@centos7 tftpboot]#touch tftp.test[root@centos7 tftpboot]#cd[root@centos7 ~]#tftp 192.168.249.131tftp&gt; get tftp.testtftp&gt; quit[root@centos7 ~]# lstftp.test 2.安装DHCP服务安装dhcp服务器包 1[root@centos7 ~]# yum -y install dhcp 复制样例配置文件并覆盖原来文件，因为原配置文件为空。 1[root@centos7 dhcp]# cp /usr/share/doc/dhcp-4.2.5/dhcpd.conf.example ./dhcpd.conf 编辑配置文件，可根据实际情况来配置 123456789101112131415161718192021222324[root@centos7 ~]#vim dhcpd.conf################################配置详情############################ 缺省租约时间default-lease-time 28800;# 最大租约时间max-lease-time 43200;# 允许BOOTP启动allow bootp;# 以上都是全局参数# 子网声明和掩码subnet 192.168.249.0 netmask 255.255.255.0 &#123; # 设置地址范围 range 192.168.249.3 192.168.249.100; # 设置网关 option routers 192.168.249.2; # 设置PXE指明引导文件名称 filename "pxelinux.0"; # 设置PXE引导文件的服务器地址 next-server 192.168.249.136;&#125; 启用服务 1systemctl start dhcpd 3.安装ftp服务ftp的默认文件共享路径为：/var/ftp/pub/如需要共享文件，只需放在该目录即可，安装系统可以直接将光盘挂载至该共享文件的一个子目录即可。 安装软件包 1yum -y install vsftpd 创建挂载目录： 1mkdir /var/ftp/pub/centos7/ 挂载光盘软件安装源至文件目录： 1mount -o loop CentOS-7.5.iso /var/ftp/pub/centos7/ 启用服务： 1systemctl start vsftpd 4.编写启动菜单及复制其他文件复制相关内核及其他文件到tftp服务的文件根目录下，其中启动菜单引导文件由syslinux包提供，所以安装此包即可。 1yum -y install syslinux 复制vmlinuz、initrd.img、pxelinux.0、chain.c32、memdisk、menu.c32、mboot.c32到/var/lib/tftpboot目录下 123456[root@centos7 ~]# cd /var/ftp/pub/centos7/images/pxeboot/[root@centos7 pxeboot]# lsinitrd.img TRANS.TBL vmlinuz[root@centos7 pxeboot]# cp vmlinuz initrd.img /var/lib/tftpboot/[root@centos7 pxeboot]# cp /usr/share/syslinux/pxelinux.0 /var/lib/tftpboot[root@centos7 pxeboot]# cp /usr/share/syslinux/&#123;chain.c32,memdisk,menu.c32,mboot.c32&#125; /var/lib/tftpboot 编写启动菜单default文件 12345678910111213141516171819[root@centos7 pxeboot]# cd /var/lib/tftpboot[root@centos7 tftpboot]# mkdir pxelinux.cfg[root@centos7 tftpboot]# cd pxelinux.cfg/[root@centos7 pxelinux.cfg]# vim defaultdefault menu.c32 prompt 5 timeout 30 MENU TITLE Centos7 PXE LABEL linux_auto MENU LABEL Install Centos7 x86_64 AUTO install KERNEL vmlinuz APPEND initrd=initrd.img ks=ftp://192.168.20.77/pub/ks.cfg LABEL linux MENU LABEL Install Centos7 x86_6 KERNEL vmlinuz APPEND initrd=initrd.img inst.repo=ftp://192.168.20.77/pub/centos7[root@centos7 ~]# cd 5.注释 initrd.img该文件可以在内存当中模拟文件系统 vmlinuz则是一个缩减版的内核文件拥有一些基本的网络功能，可以控制客户端进行下一步的从文件共享系统中下载真正的内核文件和驱动文件，最后真正的内核文件解压进行接管上一个内核，开始进行软件包的真正安装等任务。 Pxelinux.0文件它可以解释default文件中的每个配置项，并根据配置项做出不同的反应。如等待的时间、启动器背景、启动菜单、内核引导等等。 Vesamenu.c32和menu.c32是syslinux所拥有众多模块中的两个，它们的功能是制定启动器使用什么模式的背景。Vesamenu.c32图形模式，menu.c32文本模式。使用时可以选择一个，这里我选择的是文本模式。 pxelinux.cfg目录，pxelinux被执行后，它会扫描该目录下是否存在指定的配置文件，如果存在，则引用被制定的配置文件。 Default文件存放于pxelinux.cfg目录中，pxelinux程序最后扫描的配置文件名就是default，所以，我们经常把启动器配置项都写入该文件中，default文件中第一行指定使用哪种形式的图形化，menu.c32为字符图形化，也可以使用图形化的菜单vesamenu.c32。prompt和timeout指定超时时间，可以有多段，使用MENU TITLE 指定主标题，不同的安装方式可以有不同LABEL，我这里有两种，手动和自动，第一种为使用ks.cfg文件自动安装，第二种使用手动方式安装。 6.安装这里同上面的IPXE一样需要创建空白虚拟机，如果需要ks无人值守全自动安装同样可以使用 kickstart配置工具system-config-kickstart生成脚本,创建文件 centos7.ks，根据自己实际情况键入内容在，同一网段下就可以实现安装CentOS7。 问题合集1.vsftpd问题合集 为vsftpd添加用户 1234# 添加新用户 Reality -d是用户的访问目录useradd -d /var/ftp/pub Reality# 为用户设置密码passwd Reality 配置vsftpd.conf` 1234567#修改ftp的根目录vim /etc/vsftpd/vsftpd.conf############################配置详情##############################local_root 针对系统用户；anon_root 针对匿名用户。+++++++ local_root=/var/www/html+++++++ chroot_local_user=YES+++++++ anon_root=/var/ftp/pub vsftpd配置完成并正常启动但是无法通过ftp协议访问 首先排查本地受否可以访问，查看vsftpd是否在运行 1systemctl status vsftpd 安装ftp命令查看是否可以ftp连接 1234567891011121314151617[root@localhost 2020-08-18]# yum -y install ftp[root@localhost 2020-08-18]# ftp 192.168.211.132Connected to 192.168.211.132 (192.168.211.132).220 (vsFTPd 3.0.2)Name (192.168.211.132:root): Reality331 Please specify the password.Password:230 Login successful.Remote system type is UNIX.Using binary mode to transfer files.ftp&gt; ls227 Entering Passive Mode (192,168,211,132,207,118).150 Here comes the directory listing.drwxr-xr-x 2 0 0 22 Aug 20 03:33 pxe-server226 Directory send OK.ftp&gt; exit221 Goodbye. 如可以本地正常访问则查看防火墙是否关闭或者是否允许vsftpd端口放行 1234567891011121314############################第一种#####################################查看vsftpd端口netstat -ntpl | grep vsftpd#安装firewalldyum install firewalld firewall-config# 查看所有打开的端口：firewall-cmd --zone=dmz --list-ports#放行vsftpd端口firewall-cmd --zone=public --add-port=21/tcp --permanent #重新加载firewall-cmd --reload############################第二种##################################### 关闭防火墙systemctl disable firewalld 2.VirtualBox搭建环境指南在VirtualBox上搭建PXE或者IPXE环境时首先要了解VirtualBox中的虚拟网络 网络模式 详情 备注 NAT〈网络地址转换模式〉 VirtualBox 中虚拟的主机（以下简称：虚拟主机）并不真实存在于网络中，宿主机和宿主机网络中的任何主机都不能直接访问虚拟主机，各虚拟主机也互不相通。虚拟主机能访 问宿主机，以及宿主机能访问的任何主机。虚拟主机访问网络是先通过 VirtualBox 转换后再发送出去的，数据接收也是先由 VirtualBox 接收后再转换转发到虚拟主机。 宿主机和宿主机网络中的任何主机都不能直接访问虚拟主机，但是VirtualBox 提供了端口转发，使得我们可以设置特定的端口供实体网络访问。 Bridged Adapter〈桥接模式〉 虚拟主机通过 VirtualBox 桥接到宿主机的一个网卡中，就像真实存在于宿主机网络中的一台主机一样。虚拟主机能与宿主机和宿主机网络中的主机完美互通。被桥接的网卡会开启混杂模式。虚拟主机网络参数 ： 手动配置成桥接的宿主机网卡的同一网段，或通过宿主机网络中的 DHCP Ser 获取。 如果宿主机在一个受限制的网络虚拟主机是不能访问互联网的，如：宿主机使用ADSL、使用使用代理或VPN、宿主机网关做了MAC地址限制…… Internal〈内部模式〉 虚拟机与外界完全分开，虚拟机与宿主机网络不能互通，只有 同一名称（如：intnet）的内部网络模式的虚拟机之间才能互相访问 ，还有一个条件是在同一网段。虚拟主机网络参数 ： 默认不分配IP，需要自已手动设置。 / Host-only Adapter〈宿主机模式〉 VirtualBox 在宿主机中虚拟一个 host-only 网卡，然后把虚拟主机桥接到 host-only 网卡上，我们可以通过设置 host-only 网卡（共享、桥接）来实现网络连接 / VirtualBox中默认的Host-only Adapter是DHCP自动分配地址的，即使关闭DHCP任然会自动配置网卡。综上所述我所采取的是俩张网卡来作为配置环境：NAT、新建的Host-only Adapter。其中NAT网卡用于连接外网，新建的Host-only Adapter用于Xshell连接与DHCP地址分配，实现对需要网络安装的客户机直接通信。 配置Host-only Adapter网卡,新建虚拟网卡：管理-&gt;主机网络管理器-&gt;新建-&gt;选中手动配置网卡-&gt;取消DHCP服务-&gt;应用 ​ 在新建好的虚拟机设置中选择网络，选择网卡1-&gt;点击启用网络连接-&gt;连接方式选择网络地址转换（NAT）；选择网卡2-&gt;点击启用网络连接-&gt;连接方式选择仅主机网络-&gt;界面名称选择刚创建的虚拟网络。 这时候有俩张网卡enp0s3(NAT)、enp0s8(Host-only)，但是后面的网卡ip是没有的需要我们自己配置，复制enp0s3的网卡配置到enp0s8 12cd /etc/sysconfig/network-scripts/cp ifcfg-enp0s3 ifcfg-enp0s8 查看enp0s8网卡的mac地址、uuid并记录 1234ifconfig -anmcli con show 编辑ifcfg-enp0s8 123456789101112131415161718192021vi ifcfg-enp0s8#########################################################配置详情######################################################TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=staticDEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=enp0s8HWADDR=08:00:27:73:09:e3UUID=a1a8cdad-3a45-32cc-a3a8-18acb8af644bDEVICE=enp0s8IPADDR=192.168.16.5GATEWAY=192.168.16.24NETMASK=255.255.255.0ONBOOT=yes 需要网络安装系统的客户机在VirtualBox上需要设置网卡与环境机的Host-only网卡一致才能实现DHCP动态分配地址以及俩个虚拟机之间的互相访问。 3.VirtualBox中使用BIOS启动TFTP连接超时 出现这个问题是因为在ipxe环境中dhcpd.conf配置的ip以及网关都是网络地址转换（NAT）,而实际中NAT模式中俩个虚拟机在VirtualBox是无法直接通信的，所以分配到的ip为NAT网卡的IP，通过TFTP去访问Host-only中的地址与NAT中的ipxe环境地址是无法访问到的，所以需要重新配置ipxe环境中的dhcp.conf将动态IP配置到与Host-only网卡一直的同一网段中，这样客户机设置的网卡为Host-only时就可以正常通过网络引导启动。具体VirtualBox网络模式可参考VirtualBox搭建环境指南。 4.VirtualBox中BIOS安装失败：“FATAL:No bootable medium found!System halted.”经过确认默认情况下VirtualBox下载安装后是不支持PXE启动的，启动的时候是会报上面的错误，这是因为缺少pxe扩展包所导致，通过下面这个地址下载扩展包 选择下载对应VirtualBox的拓展包安装即可，最后，在全局设定—&gt;拓展中可以安装拓展包，之后在设置—系统中更改启动顺序，优先使用网路启动，如果你的网络环境支持PXE启动，就可以使用网络安装了。]]></content>
      <categories>
        <category>IPXE</category>
      </categories>
      <tags>
        <tag>IPXE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Rust]]></title>
    <url>%2F2020%2F06%2F13%2F%E8%AE%B0%E4%B8%80%E6%AC%A1Rust%E5%88%9D%E5%AD%A6%E5%8E%86%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[初识RustRust简介Rust是由Mozilla主导开发的通用、编译型编程语言。 设计准则为“安全、并发、实用”，支持函数式、並行式、程序式以及面向对象的编程风格 ， 它有着惊人的运行速度（有些领域甚至超过 C/C++），能够防止运行错误，并保证线程安全。RUST 语言使每个人都能够构建可靠、高效的软件。 为了实现安全、速度和斌发行，它没有采用垃圾回收机制（GC）。这让它在其它语言并不擅长的场景中大展身手： 嵌入到其它语言中、在特定的时间和空间要求下编程、编写例如设备驱动和操作系统这样的底层代码。它通过一系列不产生运行时开销的编译时安全检查来提升目前语言所关注的领域，同时消除一切数据竞争。Rust 还致力于实现“零开销抽象”，虽然有些抽象看起来更像一个高级语言的特性。即便如此，你仍然可以使用 Rust 来做一些底层的精准控制。 学习工具集 学习网址 类型 https://www.rust-lang.org/ 官网 https://crates.io/ 包管理平台 https://docs.rs/ 文档中心 https://kaisery.github.io/trpl-zh-cn/ 中文电子书 入门指南在Windows上安装首先，需要安装最新版的 Rust 编译工具和 Visual Studio Code，具体编译工具以及Vs code安装教程自行百度。 Rust 编译工具：https://www.rust-lang.org/zh-CN/tools/install Rust 的编译工具依赖 C 语言的编译工具，这意味着你的电脑上至少已经存在一个 C 语言的编译环境。如果你使用的是 Linux 系统，往往已经具备了 GCC 或 clang。如果你使用的是 macOS，需要安装 Xcode。如果你是用的是 Windows 操作系统，你需要安装 Visual Studio 2013 或以上的环境（需要 C/C++ 支持）以使用 MSVC 或安装 MinGW + GCC 编译环境（Cygwin 还没有测试）。 Hello，World！接下来，新建一个源文件，命名为 main.rs。Rust 源文件总是以 .rs 扩展名结尾。如果文件名包含多个单词，使用下划线分隔它们。例如命名为 hello_world.rs，而不是 helloworld.rs。 现在打开刚创建的 main.rs 文件，输入示例 代码。 文件名: main.rs 123fn main() &#123; println!("Hello, world!");&#125; 保存文件，并回到终端窗口。在 Linux 或 macOS 上，输入如下命令，编译并运行文件： 123$ rustc main.rs$ ./mainHello, world! 在 Windows 上，输入命令 .\main.exe，而不是 ./main： 123&gt; rustc main.rs&gt; .\main.exeHello, world! 不管使用何种操作系统，终端应该打印字符串 Hello, world!。 如果出现以下错误提示，需要在 windows平台上先安装 Microsoft C++ build tools 123456789error: linker `link.exe` not found | = note: 系统找不到指定的文件。 (os error 2)note: the msvc targets depend on the msvc linker but `link.exe` was not foundnote: please ensure that VS 2013, VS 2015, VS 2017 or VS 2019 was installed with the Visual C++ optionerror: aborting due to previous error 点击 Microsoft C++ build tools，进行下载安装。 搭建 Visual Studio Code 开发环境Visual Studio Code：https://code.visualstudio.com/Download 下载完 Visual Studio Code 安装包之后启动安装向导安装（此步骤不在此赘述）。 安装完 Visual Studio Code （下文简称 VSCode）之后运行 VSCode。使用快捷键ctrl+p ，输入内容 ext 后空格，按下Enter 拓展搜索框输入Chinese，安装简体中文扩展，使界面变成中文。 用同样的方法安装 rls 和 Native Debug 两个扩展。 重新启动 VSCode，Rust 的开发环境就搭建好了。 在D盘目录下创建Rust Workspace文件夹， 在 VSCode 中打开新建的文件夹： 打开新的终端 在终端中输入命令： 1cargo new greeting 当前文件下下会构建一个名叫 greeting 的 Rust 工程目录。 现在在终端里输入以下三个命令 ： 123cd ./greeting cargo build cargo run 系统在创建工程时会生成一个 Hello, world 源程序 main.rs，这时会被编译并运行： 猜猜看游戏帮助入门获取用户输入内容首先在刚才创建的工程下的main.rs下输入以下示例代码： 123456789101112use std::io;fn main() &#123; let hello=String::from("Hello,World! Hello, Rust!"); println!("&#123;&#125;",hello); println!("Guess the number !"); println!("Please input your guess."); let mut guess=String::new(); io::stdin().read_line(&amp;mut guess) .expect("Failed to read line"); println!("You guessed: &#123;&#125;",guess); &#125; 接下来我们分析代码中的信息，猜猜看游戏的主要操作是用户提供输入，控制台反馈用户所猜的内容，那么我们需要将io（输入/输出）库引入到当前的作用域，其中io库来自标准库（也被称作std）Rust将少量的类型引入到每个程序的作用域中，如果需要的类型不在模块中需要使用到use语句来显式的将其引入作用域。 1use std::id; 接下来 main函数是程序的入口点： 1fn main（）&#123; 其中fn用来声明一个新的函数，（）表明没有参数，{作为函数体的开始。 之后一系列的println!表示是一个在屏幕上打印字符串的宏 ): 123println!("Hello, world!");println!("Guess the number !");println!("Please input your guess."); 这些代码用于在控制台打印，提示并介绍游戏内容供用户输入。接下来创建一个存储用户输入的地方，像这样： 1let mut guess=String::new(); 我们可以看到这是一个let语句，用来创建变量 （variable）。之所以let后面多了一个修饰词mut,是因为 在 Rust 中，变量默认是不可变的，在变量名前使用 mut 来使一个变量可变： 12let a = 5; // 不可变let mut b = 5; // 可变 让我们回到猜猜看程序中。现在我们知道了 let mut guess 会引入一个叫做 guess 的可变变量。等号（=）的右边是 guess 所绑定的值，它是 String::new 的结果，这个函数会返回一个 String 的新实例。String是一个标准库提供的字符串类型，它是 UTF-8 编码的可增长文本块。 ::new 那一行的 :: 语法表明 new 是 String 类型的一个 关联函数（associated function）。关联函数是针对类型实现的，在这个例子中是 String，而不是 String 的某个特定实例。一些语言中把它称为 静态方法（static method）。new 函数创建了一个新的空字符串，你会发现很多类型上有 new 函数，因为它是创建类型实例的惯用函数名。 总结一下，let mut guess = String::new(); 这一行创建了一个可变变量，当前它绑定到一个新的 String 空实例上，接下来我们需要做的是获取到用户从键盘上输入的变量，于是调用io库中的stdin函数： 12io::stdin().read_line(&amp;mut guess) .expect("Failed to read line"); 如果未在程序开头声明将io库引入到程序中此时的io::stdin()应该替换为std::io::stdin()。代码的下一部分.readline(&amp;mut guess)方法从标准输入句柄中获取用户输入，我们还想read_line传递了一个参数：&amp;mut guess。由于read_line是无论用户在标准输入中输入什么内容，它都会将其存入到一个字符串中，所以它需要字符串作为参数，并且由于是通过用户键入赋值，所以将其设置为可变的。 &amp; 表示这个参数是一个 引用（reference），它允许多处代码访问同一处数据，而无需在内存中多次拷贝。引用是一个复杂的特性，Rust 的一个主要优势就是安全而简单的操纵引用。完成当前程序并不需要了解如此多细节。现在，我们只需知道它像变量一样，默认是不可变的。因此，需要写成 &amp;mut guess 来使其可变，而不是 &amp;guess。 接下来的代码是使用 println! 占位符进行打印值 1println!("You guessed: &#123;&#125;", guess); 这行代码打印存储用户输入的字符串。第一个参数是格式化字符串，里面的 {} 是预留在特定位置的占位符。使用 {} 也可以打印多个值：第一对 {} 使用格式化字符串之后的第一个值，第二对则使用第二个值，依此类推。调用一次 println! 打印多个值看起来像这样： 123let x = 5;let y = 10;println!("x = &#123;&#125; and y = &#123;&#125;", x, y); 这行代码会打印出 x = 5 and y = 10。当然也有更好的写法： 123let x = 5;let y = 10;println!("x = &#123;0&#125; and y = &#123;1&#125;", x, y); 在 {} 之间可以放一个数字，它将把之后的可变参数当作一个数组来访问，下标从0 开始。 如果要输出 {或 }怎么办呢？格式字符串中通过分别转义代表 { 和 }。但是其他常用转义字符与 C 语言里的转义字符一样，都是反斜杠开头的形式。 123fn main() &#123; println!("&#123;&#123;&#125;&#125;"); &#125; 生成一个秘密数字 接下来，需要生成一个秘密数字，好让用户来猜。秘密数字应该每次都不同，这样重复玩才不会乏味；范围应该在 1 到 100 之间，这样才不会太困难。Rust 标准库中尚未包含随机数功能。然而，Rust 团队还是提供了一个 rand库。 在我们使用 rand 编写代码之前，需要修改 Cargo.toml 文件，引入一个 rand 依赖。现在打开这个文件并在底部的 [dependencies] 片段标题之下添加： 123[dependencies]rand = "0.5.5" 在 Cargo.toml 文件中，标题以及之后的内容属同一个片段，直到遇到下一个标题才开始新的片段。[dependencies] 片段告诉 Cargo 本项目依赖了哪些外部 crate 及其版本。本例中，我们使用语义化版本 0.5.5 来指定 rand 库。Cargo 理解语义化版本（Semantic Versioning）（有时也称为 SemVer），这是一种定义版本号的标准。0.5.5 事实上是 ^0.5.5 的简写，它表示 “任何与 0.5.5 版本公有 API 相兼容的版本”。现在，不修改任何代码，构建项目，这时候的控制面板可能卡在Blocking waiting for file lock on package cache通过百度查询建议可以设置cargo用的镜像：在你的CARGO_HOME目录下(默认是~/.cargo)建立一个名叫config没有扩展名【切记，没有扩展名！】的文件，内容如下：（有人的网络环境受限，没有办法以git协议访问外网，请把下一行里的git://换成https://或者http://） 12345[source.crates-io]registry = "https://github.com/rust-lang/crates.io-index"replace-with = 'tuna'[source.tuna]registry = "https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git" 验证：在命令行中运行 cargo install cargo-release，会成功安装一个小程序，第一次下载的时候会很慢，因为有大约四百兆的初始索引数据要下载。 现在，不修改任何代码，构建项目 : 1234567891011121314$ cargo build Updating crates.io index Downloaded rand v0.5.5 Downloaded libc v0.2.62 Downloaded rand_core v0.2.2 Downloaded rand_core v0.3.1 Downloaded rand_core v0.4.2 Compiling rand_core v0.4.2 Compiling libc v0.2.62 Compiling rand_core v0.3.1 Compiling rand_core v0.2.2 Compiling rand v0.5.5 Compiling guessing_game v0.1.0 (file:///projects/guessing_game) Finished dev [unoptimized + debuginfo] target(s) in 2.53 s Cargo.lock 文件确保构建是可重现的,这个问题的答案是 Cargo.lock 文件。它在第一次运行 cargo build 时创建，并放在 guessing_game 目录。当第一次构建项目时，Cargo 计算出所有符合要求的依赖版本并写入 Cargo.lock 文件。当将来构建项目时，Cargo 会发现 Cargo.lock 已存在并使用其中指定的版本，而不是再次计算所有的版本。这使得你拥有了一个自动化的可重现的构建。换句话说，项目会持续使用 0.5.5 直到你显式升级，多亏有了 Cargo.lock 文件。 接下来更新main.rs生成随机数 12345678910111213141516use std::io;use rand::Rng;fn main() &#123; let hello = String::from("Hello,World! Hello, Rust!"); println!("&#123;&#125;", hello); let secret_number=rand::thread_rng().gen_range(1,101); println!("Guess the number !"); println!("Please input your guess."); let mut guess = String::new(); io::stdin() .read_line(&amp;mut guess) .expect("Failed to read line"); println!("You guessed: &#123;&#125;", guess); println!("The secret number is: &#123;&#125;", secret_number);&#125; 首先，我们新增了一行 use：use rand::Rng。Rng 是一个 trait，它定义了随机数生成器应实现的方法，想使用这些方法的话，此 trait 必须在作用域中。第十章会详细介绍 trait。 接下来，我们在中间还新增加了两行。rand::thread_rng 函数提供实际使用的随机数生成器：它位于当前执行线程的本地环境中，并从操作系统获取 seed。接下来，调用随机数生成器的 gen_range 方法。这个方法由刚才引入到作用域的 Rng trait 定义。gen_range 方法获取两个数字作为参数，并生成一个范围在两者之间的随机数。它包含下限但不包含上限，所以需要指定 1 和 101 来请求一个 1 和 100 之间的数。 新增加的第二行代码打印出了秘密数字。 比较输入、秘密数字 现在有了用户输入和一个随机数，我们可以比较它们。 1234567891011121314/* *Rust 有一个静态强类型系统，同时也有类型推断。当我们写出 let guess = String::new() 时， *Rust 推断出 guess 应该是 String 类型，并不需要我们写出类型。另一方面，secret_number， *是数字类型。几个数字类型拥有 1 到 100 之间的值：32 位数字 i32；32 位无符号数字 u32； *64 位数字 i64 等等。Rust 默认使用 i32，所以它是 secret_number 的类型，除非增加类型信息， *或任何能让 Rust 推断出不同数值类型的信息，所以通过以下方法来转换为数字类型 */ let guess: u32 = guess.trim().parse().expect("Please type a number!");match guess.cmp(&amp;secret_number) &#123; Ordering::Less =&gt; println!("Too small!"), Ordering::Greater =&gt; println!("Too big!"), Ordering::Equal =&gt; println!("You win!"),&#125; 不过等等，不是已经有了一个叫做 guess 的变量了吗？确实如此，不过 Rust 允许用一个新值来 隐藏 （shadow） guess 之前的值。这个功能常用在需要转换值类型之类的场景。它允许我们复用 guess 变量的名字，而不是被迫创建两个不同变量， 我们将 guess 绑定到 guess.trim().parse() 表达式上。表达式中的 guess 是包含输入的原始 String 类型。String 实例的 trim 方法会去除字符串开头和结尾的空白字符。u32 只能由数字字符转换，不过用户必须输入 enter 键才能让 read_line 返回，然而用户按下 enter 键时，会在字符串中增加一个换行（newline）符。例如，用户输入 5 并按下 enter，guess 看起来像这样：5\n。\n 代表 “换行”，回车键。trim 方法消除 \n，只留下 5。字符串的 parse 方法将字符串解析成数字。因为这个方法可以解析多种数字类型，因此需要告诉 Rust 具体的数字类型，这里通过 let guess: u32 指定。guess 后面的冒号（:）告诉 Rust 我们指定了变量的类型。Rust 有一些内建的数字类型；u32 是一个无符号的 32 位整型。对于不大的正整数来说，它是不错的类型，第三章还会讲到其他数字类型。另外，程序中的 u32 注解以及与 secret_number 的比较，意味着 Rust 会推断出 secret_number 也是 u32 类型。现在可以使用相同类型比较两个值了！ parse 调用很容易产生错误。例如，字符串中包含 A👍%，就无法将其转换为一个数字。因此，parse 方法返回一个 Result 类型。像之前 “使用 Result 类型来处理潜在的错误“讨论的 read_line 方法那样，再次按部就班的用 expect 方法处理即可。如果 parse 不能从字符串生成一个数字，返回一个 Result 的 Err 成员时，expect 会使游戏崩溃并打印附带的信息。如果 parse 成功地将字符串转换为一个数字，它会返回 Result 的 Ok 成员，然后 expect 会返回 Ok 值中的数字 现在游戏已经大体上能玩了，不过用户只能猜一次。增加一个循环来改变它吧！ loop 关键字创建了一个无限循环。将其加入后，用户可以反复猜测， 用户总能使用 ctrl-c 终止程序。 1234567891011121314151617181920212223242526loop &#123; println!("Please input your guess."); let mut guess = String::new(); /* *获取用户输入 */ io::stdin() .read_line(&amp;mut guess) .expect("Failed to read line"); /* *Rust 有一个静态强类型系统，同时也有类型推断。当我们写出 let guess = String::new() 时， *Rust 推断出 guess 应该是 String 类型，并不需要我们写出类型。另一方面，secret_number， *是数字类型。几个数字类型拥有 1 到 100 之间的值：32 位数字 i32；32 位无符号数字 u32； *64 位数字 i64 等等。Rust 默认使用 i32，所以它是 secret_number 的类型，除非增加类型信息， *或任何能让 Rust 推断出不同数值类型的信息，所以通过以下方法来转换为数字类型 */ let guess: u32 = guess.trim().parse().expect("Please type a number!"); match guess.cmp(&amp;secret_number) &#123; Ordering::Less =&gt; println!("Too small!"), Ordering::Greater =&gt; println!("Too big!"), Ordering::Equal =&gt; println!("You win!"), &#125; println!("You guessed: &#123;&#125;", guess); println!("The secret number is: &#123;&#125;", secret_number); &#125; 让我们增加一个 break 语句，在用户猜对时退出游戏： 12345678match guess.cmp(&amp;secret_number) &#123; Ordering::Less =&gt; println!("Too small!"), Ordering::Greater =&gt; println!("Too big!"), Ordering::Equal =&gt; &#123; println!("You win!"); break; &#125;, &#125; 通过在 You win! 之后增加一行 break，用户猜对了神秘数字后会退出循环。退出循环也意味着退出程序，因为循环是 main 的最后一部分。 最终代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546use rand::Rng;use std::cmp::Ordering;use std::io;fn main() &#123; let hello = String::from("Hello,World! Hello, Rust!"); println!("&#123;&#125;", hello); /* *生成随机数 */ let secret_number = rand::thread_rng().gen_range(1, 101); println!("Guess the number !"); loop &#123; println!("Please input your guess."); let mut guess = String::new(); /* *获取用户输入 */ io::stdin() .read_line(&amp;mut guess) .expect("Failed to read line"); /* *Rust 有一个静态强类型系统，同时也有类型推断。当我们写出 let guess = String::new() 时， *Rust 推断出 guess 应该是 String 类型，并不需要我们写出类型。另一方面，secret_number， *是数字类型。几个数字类型拥有 1 到 100 之间的值：32 位数字 i32；32 位无符号数字 u32； *64 位数字 i64 等等。Rust 默认使用 i32，所以它是 secret_number 的类型，除非增加类型信息， *或任何能让 Rust 推断出不同数值类型的信息，所以通过以下方法来转换为数字类型 */ let guess: u32 = match guess.trim().parse() &#123; Ok(num) =&gt; num, Err(_) =&gt; continue, &#125;; /* *比较用户输入与随机生成 */ match guess.cmp(&amp;secret_number) &#123; Ordering::Less =&gt; println!("Too small!"), Ordering::Greater =&gt; println!("Too big!"), Ordering::Equal =&gt; &#123; println!("You win!"); break; &#125; &#125; println!("You guessed: &#123;&#125;", guess); println!("The secret number is: &#123;&#125;", secret_number); &#125;&#125; 总结本章通过简略介绍Rust、环境搭建以及动手实践，向你介绍了 Rust 新概念：let、match、方法、关联函数、使用外部 资源库 等等，这样我们就算初步认识Rust了为后续学习Rust打定了基础。]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot+Dubbo+Zookeeper简单集成分布式]]></title>
    <url>%2F2019%2F03%2F27%2FSpringBoot-Dubbo-Zookeper%2F</url>
    <content type="text"><![CDATA[Spring Boot+Dubbo+Zookeeper简单集成分布式dubbo是阿里公司推出解决分布式服务问题的框架，是一个基于SOA面向服务体系结构的基础设施，提供了诸如服务发布注册、容错调用、部署、调用次数监控、每个服务的性能监控等很多功能。 Dubbo建议使用Zookeeper作为服务的注册中心。 Zookeeper的作用： ​ zookeeper用来注册服务和进行负载均衡，哪一个服务由哪一个机器来提供必需让调用者知道，简单来说就是ip地址和服务名称的对应关系。当然也可以 通过硬编码的方式把这种对应关系在调用方业务代码中实现，但是如果提供服务的机器挂掉调用者无法知晓，如果不更改代码会继续请求挂掉的机器提供服务。 zookeeper通过心跳机制可以检测挂掉的机器并将挂掉机器的ip和服务对应关系从列表中删除。至于支持高并发，简单来说就是横向扩展，在不更改代码 的情况通过添加机器来提高运算能力。通过添加新的机器向zookeeper注册服务，服务的提供者多了能服务的客户就多了。 dubbo： ​ 是管理中间层的工具，在业务层到数据仓库间有非常多服务的接入和服务提供者需要调度，dubbo提供一个框架解决这个问题。 ​ 注意这里的dubbo只是一个框架，至于你架子上放什么是完全取决于你的，就像一个汽车骨架，你需要配你的轮子引擎。这个框架中要完成调度必须要有一个分布式的注册中心，储存所有服务的元数据，你可以用zk，也可以用别的，只是大家都用zk。 zookeeper和dubbo的关系： ​ Dubbo的将注册中心进行抽象，是得它可以外接不同的存储媒介给注册中心提供服务，有ZooKeeper，Memcached，Redis等。 ​ 引入了ZooKeeper作为存储媒介，也就把ZooKeeper的特性引进来。首先是负载均衡，单注册中心的承载能力是有限的，在流量达到一定程度的时 候就需要分流，负载均衡就是为了分流而存在的，一个ZooKeeper群配合相应的Web应用就可以很容易达到负载均衡；资源同步，单单有负载均衡还不 够，节点之间的数据和资源需要同步，ZooKeeper集群就天然具备有这样的功能；命名服务，将树状结构用于维护全局的服务地址列表，服务提供者在启动 的时候，向ZK上的指定节点/dubbo/${serviceName}/providers目录下写入自己的URL地址，这个操作就完成了服务的发布。 其他特性还有Mast选举，分布式锁等。下面是简单的实现Spring Boot+Dubbo+Zookeeper简单集成 1.首先在win或linux下安装zookeeper，这里以win环境下进行安装Zookeeper. 在官网https://mirrors.cnnic.cn/apache/zookeeper/下载zookeeper. 把下载的zookeeper的文件解压到指定目录 1234567891011121314151617D:\machine\zookeeper-3.3.6&gt;修改conf下增加一个zoo.cfg内容如下：# The number of milliseconds of each tick 心跳间隔 毫秒每次tickTime=2000# The number of ticks that the initial# synchronization phase can takeinitLimit=10# The number of ticks that can pass between# sending a request and getting anacknowledgementsyncLimit=5# the directory where the snapshot isstored. //镜像数据位置dataDir=D:\\data\\zookeeper#日志位置dataLogDir=D:\\logs\\zookeeper# the port at which the clients willconnect 客户端连接的端口clientPort=2181 注：如果启动有报错提示cfg文件有错误，可以用zoo_sample.cfg内内容替代也是可以的 进入到bin目录，并且启动zkServer.cmd，这个脚本中会启动一个java进程 123D:\machine\zookeeper-3.3.6&gt;cd binD:\machine\zookeeper-3.3.6\bin&gt;D:\machine\zookeeper-3.3.6\bin &gt;zkServer.cmd 2.创建生产者及消费者demo目录格式如下： 将必须的jar导入到dubbo及dubboapi的pom.xml中 123456789101112131415161718192021222324&lt;!--引入zookeeper--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入dubbo--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--引入zookeeper客户端--&gt;&lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.10&lt;/version&gt;&lt;/dependency&gt; 3.dubbo配置文件分别在服务端和消费端下的resources下创建provider.xml及customer.xml provider.xml: 12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"&gt; &lt;!--配置服务名称--&gt; &lt;dubbo:application name="provider" /&gt; &lt;!--配置服务注册中心，dubbo不仅仅支持zookeeper--&gt; &lt;dubbo:registry address="zookeeper://127.0.0.1:2181" /&gt; &lt;!--声明对外暴露的服务--&gt; &lt;dubbo:service interface="com.example.dubbo.service.UserService" ref="UserService" /&gt; &lt;bean id="demoService" class="com.example.dubbo.service.impl.UserServiceImpl"&gt;&lt;/bean&gt;&lt;/beans&gt; customer.xml:这里配置和provider.xml的时候有点不一样，不用注入bean 123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"&gt; &lt;!--配置服务名称--&gt; &lt;dubbo:application name="customer" /&gt; &lt;!--配置服务注册中心，dubbo不仅仅支持zookeeper--&gt; &lt;dubbo:registry address="zookeeper://127.0.0.1:2181" /&gt; &lt;!--声明服务引用，与服务声明接口类型一致--&gt; &lt;dubbo:reference interface="com.example.dubbo.service.UserService" id="UserService" /&gt;&lt;/beans&gt; 4.编写测试类这里的接口与实体类是服务端和客户端共同都有的 编写po： 1234567891011121314151617package com.example.dubbo.po;import lombok.Data;import java.io.Serializable;/** * @Description : * @Author : 苏俊强 * @Date : 2019/3/25 */@Datapublic class User implements Serializable &#123; private static final long serialVersionUID = 1L; private int id; private String password;&#125; 编写service 12345678910111213package com.example.dubbo.service;import com.example.dubbo.po.User;/** * @Description : * @Author : 苏俊强 * @Date : 2019/3/25 */public interface UserService &#123; User selectUserById(int id);&#125; 在服务端编写impl 123456789101112131415161718192021package com.example.dubbo.service.impl;import com.example.dubbo.po.User;import com.example.dubbo.service.UserService;import org.springframework.stereotype.Service;/** * @Description : * @Author : 苏俊强 * @Date : 2019/3/25 */@Service("UserService")public class UserServiceImpl implements UserService &#123; @Override public User selectUserById(int id) &#123; System.out.println("这里是dubbo的服务端"); System.out.println("需要查询的用户为" + id); return null; &#125;&#125; 在客户端编写controller 1234567891011121314151617181920212223242526package com.example.dubbo.controller;import com.example.dubbo.po.User;import com.example.dubbo.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;/** * @Description : * @Author : 苏俊强 * @Date : 2019/3/25 */@RestControllerpublic class UserController &#123; @Autowired private UserService userService; @GetMapping("selectUserById/&#123;id&#125;") public String selectUserById(@PathVariable("id") int id)&#123; System.out.println(id); User user= userService.selectUserById(id); return "ok"; &#125;&#125; 至于如何使用dubbo-admin 监控搭建，读者可参考https://blog.csdn.net/evankaka/article/details/47858707 源码下载https://github.com/su-junqiang/dubbo-zookeper-demo.git]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux安装jdk1.8&&设置Tomcat为开机启动服务&&MySQL外网访问&&redis安装配置]]></title>
    <url>%2F2019%2F01%2F01%2Flinux%26%26jdk%26%26mysql%26%26redis%2F</url>
    <content type="text"><![CDATA[linux安装jdk1.8解压jdk安装包：附上jdk1.8的下载地址：http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 将jdk-8u192-linux-x64.tar.gz下载到本地用xftp将其上传至xshell中自己指定的下载目录 使用以下命令将其解压 12tar -zxvf jdk1.8.0_191.tar.gz //解压安装包到当前文件夹 mv jdk1.8.0_191 java1.8 //重命名 之后配置一下环境变量。 编辑/etc/下的profile文件，配置环境变量 1sudo vi /etc/profile // 到profile配置环境变量 在profile文件添加以下内容 123export JAVA_HOME=/root/server/jdk1.8 //jdk1.8的目录 export JRE_HOME=$&#123;JAVA_HOME&#125;/jre export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 之后保存并退出文件之后在控制台输入Java 和 Java -version 看有没有信息输出，如下： 12java -version java version &quot;1.8.0_191&quot; //版本号 Java(TM) SE Runtime Environment (build 1.8.0_191-b12) Java HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode) 能显示以上信息，就说明jdk安装成功啦 linux设置Tomcat为开机启动服务解压tomcat安装包附上tomcat8的下载地址https://tomcat.apache.org/download-80.cgi 将tar.gz (pgp, sha512)下载到本地用xftp将其上传至xshell中自己指定的下载目录 使用以下命令将其解压 12tar -zxvf apache-tomcat-8.5.35.tar.gz //解压安装包到当前文件夹 mv apache-tomcat-8.5.35 tomcat8 //重命名 将tomcat安装目录下bin文件夹中的catalina.sh拷贝到/etc/init.d下并修改名称为tomcat 12cp /tomcat8/bin/catalina.sh /etc/init.d/ mv /etc/init.d/catalina.sh tomcat //将服务重命名为tomcat 分别执行上面三条命令，如果提示错误在开头加上sudo，然后配置/etc/init.d/tomcat添加以下内容 12CATALINA_HOME=/root/server/tomcat8 //tomcat8的目录 JAVA_HOME=/root/server/jdk1.8 //jdk1.8的目录 CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$CATALINA_HOME/lib 之后保存并退出文件之后进行添加开机自启服务 1234apt install sysv-rc-conf //首先安装sysv-rc-conf update-rc.d –f tomcat remove sysv-rc-conf tomcat on sysv-rc-conf tomcat --list 重启 12reboot netstat -ntlp //查看端口8080是否启动 linux设置MySQL外网访问通过apt-get安装mysql 123sudo apt-get install mysql-server apt-get install mysql-client apt-get install mysql-client 进入MySQL配置允许外网访问 123mysql -uroot -p //输入密码 use mysql select host,user from user; 实现远程连接(授权法)将host字段的值改为%就表示在任何客户端机器上能以root用户登录到mysql服务器，建议在开发时设为%。 12update user set host=&apos;%&apos; where user=&apos;root&apos;;flush privileges; 授权用户 任意主机以用户root和密码mypwd连接到mysql服务器 1GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;mypwd&apos; WITH GRANT OPTION; flush privileges; IP为192.168.1.102的主机以用户myuser和密码mypwd连接到mysql服务器 12GRANT ALL PRIVILEGES ON *.* TO &apos;myuser&apos;@&apos;192.168.1.102&apos; IDENTIFIED BY &apos;mypwd&apos; WITH GRANT OPTION; flush privileges; linux安装配置redis通过wget下载redis的压缩包12wget http://download.redis.io/releases/redis-5.0.3.tar.gz //redis wget下载 tar xzf redis-5.0.3.tar.gz //解压redis包 进入redis-5.0.3下的src目录 1cd redis-5.0.3/src make install PREFIX=/usr/local/redis //注意:make编译如果失败，因为没有安装gcc服务 安装gcc服务，之后提示下载文件y确认 1yum install gcc 输入 make PREFIX=/usr/local/redis install 安装redis 到 目录 /usr/local/redis 123456Hint: It&apos;s a good idea to run &apos;make test&apos; ;) INSTALL install INSTALL install INSTALL install INSTALL install INSTALL install 以上提醒表明安装成功。 进入安装目录，查看 bin 目录下的文件 123cd /usr/local/redis/bin ls redis-benchmark redis-check-aof redis-check-rdb redis-cli redis-sentinel redis-server 其中： redis-benchmark —-性能测试工具 redis-check-aof —-AOF文件修复工具 redis-check-dump —-RDB文件检查工具（快照持久化文件） redis-cli —-命令行客户端 redis-server —-redis服务器启动命令 配置 redis.conf,进入一开始解压的文件夹 1cd /root/server/redis ls cp redis.conf /usr/local/redis/ 修改redis.conf配置文件 1sudo vi redis.conf daemonize yes 将 daemonize no 修改为 daemonize yes 这样便可以以后端模式启动 启动redis服务 进入安装目录 /usr/local/redis/ ，命令行： cd /usr/local/redis/ 1./bin/redis-server ./redis.conf]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Linux</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不同的 SQL JOIN]]></title>
    <url>%2F2018%2F12%2F29%2FSql%26%26Join%2F</url>
    <content type="text"><![CDATA[INNER JOIN内连接是最常见的一种连接，只连接匹配的行。 inner join语法 1select column_name(s) from table 1 INNER JOIN table 2 ON table 1.column_name=table 2.column_name 注释：INNER JOIN与JOIN是相同 INNER JOIN产生的结果集中，是1和2的交集。 LEFT JOIN返回左表的全部行和右表满足ON条件的行，如果左表的行在右表中没有匹配，那么这一行右表中对应数据用NULL代替。 LEFT JOIN 语法 1select column_name(s) from table 1 LEFT JOIN table 2 ON table 1.column_name=table 2.column_name 注释：在某些数据库中，LEFT JOIN 称为LEFT OUTER JOIN LEFT JOIN产生表1的完全集，而2表中匹配的则有值，没有匹配的则以null值取代。 RIGHT JOINRIGHT JOIN返回右表的全部行和左表满足ON条件的行，如果右表的行在左表中没有匹配，那么这一行左表中对应数据用NULL代替。 RIGHT JOIN语法 1select column_name(s) from table 1 RIGHT JOIN table 2 ON table 1.column_name=table 2.column_name 注释：在某些数据库中，RIGHT JOIN 称为RIGHT OUTER JOIN RIGHT JOIN产生表2的完全集，而1表中匹配的则有值，没有匹配的则以null值取代。 FULL JOIN会从左表 和右表 那里返回所有的行。如果其中一个表的数据行在另一个表中没有匹配的行，那么对面的数据用NULL代替 FULL OUTER JOIN语法 1select column_name(s) from table 1 FULL OUTER JOIN table 2 ON table 1.column_name=table 2.column_name FULL OUTER JOIN产生1和2的并集。但是需要注意的是，对于没有匹配的记录，则会以null做为值。]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中的for循环与SQL]]></title>
    <url>%2F2018%2F12%2F29%2Fjava%26%26for%2F</url>
    <content type="text"><![CDATA[java中的for循环基础的for循环123for (int i = 0; i &lt; players.size(); i++) &#123;System.out.println(players.get(i));&#125; 以前的循环方式123for (String player : players) &#123;System.out.print(player + ";\n ");&#125; 使用 lambda 表达式以及函数操作(functional operation)1players.forEach((player) -&gt; System.out.print(player + ";\n ")); 在 Java 8 中使用双冒号操作符(double colon operator)1players.forEach(System.out::println); Java数据类型和MySql数据类型对应表]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令详解]]></title>
    <url>%2F2018%2F12%2F29%2Fgit%26%26command%2F</url>
    <content type="text"><![CDATA[配置账号信息1234git config --global user.name ***git config --global user.email ***@***.***git config --list# 查看配置的信息git help config# 获取帮助信息 生成密钥1ssh-keygen -t rsa -C ***@***.*** 初始化初始化一个目录为工作目录1git init 向临时仓库添加文件’ . ‘表示全部添加，当你需要添加刚才所修改的所有文件时，就可用点表示。当然，你也可以添加具体某一文件，如git add a.doc 123git add . 创建新分支：git branch new_featuregit 切换到另一分支: checkout new_feature 向永久仓库提交文件add 命令是向git的临时仓库提交，临时仓库类似缓冲区，commit 表示真正的向代码库提交。 1git commit . -m &quot;注释部分&quot; 创建并切换分支建立分支是创建代码的独立版本的动作，独立于主干分支[主分支(名称叫做master)，即是我们干刚提交的分支，当你没有指定时，git会默认帮我们提交到主分支上。主分支是默认生成的，其它分支需要自己创建]。 创建并同时切换到你新建的分支，发送： 1git checkout -b new_feature 上面的命令我们可以分两步执行，先创建一个分支然后手动切换，就像这样： 如果要看在项目下所有的分支，发送这个： 1git branch 现在你可以在你的项目上无所顾忌地做任何你想做的：任何时候，你都可以回到你创建分支前的状态。 合并分支当我们对分支上的新功能满意了的时候，就需要把它加到主干分支上。当我们在自己的新功能分支上时，首先需要加载（stage）并且提交你的文件： 1git add .t commit -m &quot;adds my new feature&quot; 然后我们移到自己的主干分支： 1git checkout master 像这样合并： 1git merge new_feature 此时，你的主干分支和你的新功能分支会变成一样的。 版本回退git会帮你记录你的任何一次提交（所以，提交时写注释是很需要的，方便我们找回以前版本），何时切换了哪些分支等等。查看的命令很简单： 1git reflog 你会发现git是用一些不规律的16进制数代表一个版本，我们如果想回到某一个以前的版本，可以用下面的命令： 12git reset --hard 该版本的16进制数 (注：只需写前几位即可，git会自己去寻找) 如果不是特殊情况，我们应该很少去回退到特别古老的版本，最常用的莫过于对自己刚刚做的修改不满意，（在上一次commit之后做了修改，之后还没有做add和commit操作）想撤回到上一次的commit。你只需写一个命令即可回退到刚才commit的状态: 12git checkout -- . (特别注意：checkout后面是两杠-- 如果没有这两杠是什么？ 就是切换分支了！要特别注意！当然，--后面还需要 &apos; . &apos;， 表示全部撤回。) 标签12345678git tag v1.0# 新建标签 git tag -a v1.0 -m &apos;my version 1.0&apos;# 新建带注释标签 git checkout tagname# 切换到标签 git tag# 列出现有标签 push origin v1.5# 推送分支到源上 git push origin --tags# 一次性推送所有分支 git tag -d v1.0# 删除标签 git push origin :refs/tags/v1.0# 删除远程标签 上传文件到远程代码库之所以说git 强大，是因为我们刚刚所有的操作都是在本地完成的，不需要联网，不需要自己额外建库，这是svn，cvs等其它版本管理工具做不到的。但这样岂不是不能团队合作了？ 别急，这就有了github，bitbucket等网站，它们为开发者免费提供远程代码库。我们可以很方便的将自己的代码存储到上面，也可以很方便的将远程库的代码pull到本地，实现团队开发。 本地库与远程库进行绑定： 1git remote add origin git@server-name:path/repo-name.git 接着我们就向这个远程仓库提交代码： git push origin 本地分支名称:远程分支名称 (应该很好理解，push代表上传命令，‘ ： ’左边写上本地的需要上传的分支名称，右边写上将这个分支上传到服务的分支名称，) git push origin master (将本地的master分支推送到远程master分支上，是git push origin master:master的简写形式) 在团队开发的时候，当我们需要修改一个文件，为了不必要的麻烦，一定记得要将自己的本地文件更新到远程代码库的最新版本后再做修改。更新远程代码库很简单. 1git pull origin master 使用.gitignore文件 在一个项目中，往往有些文件是无需纳入 Git 管理的，比如自动生成的文件，像日志或者编译过程中创建的文件。我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件来解决这个问题。 注意1.以# 符号开始的行都会被git忽视 2.支持glob模式匹配（即简化了的正则表达式） 示例如下： 12345678910忽略所有 .tmp 结尾的文件*.tmp###### 但 main.tmp 除外!main.tmp###### 仅仅忽略项目根目录下的 note文件/note忽略 build/ 目录下的所有文件build/会忽略 doc/notes.txt 但不包括 doc/server/notes.txtdoc/notes.txt 其他技巧在Mac系统中，有一个很讨厌的文件叫做 .DS_Store,如果我们使用Mac系统一般会在项目初始化的时候将其加入`.gitignore，但有时候会因为从Windows迁移等原因导致忘记添加并且commit进仓库了。 这时候我们需要将其移出Git仓库，步骤如下: 12find . -name .DS_Store -print0 | xargs -0 git rm -f --ignore-unmatch 然后再将`.gitignore`里添加`.DS_Store`,重新commit即可。 对于这种常用却又比较长的命令，我习惯将其组装成函数加入bashrc中 123function cleands &#123; find . -name .DS_Store -print0 | xargs -0 git rm -f --ignore-unmatch &#125; 这样，执行cleands即可。 git 默认对于文件名大小写是不敏感的,要想修正这一点，使用如下配置： 1git config core.ignorecase false 有时候commit之后突然意识到commit的信息中有单词拼错之类，想做修改： 1git commit --amend Vim在安装Vundle插件后使用Vim来commit一些信息可能会报错如下 12error: There was a problem with the editor &apos;vi&apos;. Please supply the message using either -m or -F option. 解决方式： 1git config --global core.editor $(which vim) 想让git 的log信息看起来更geek？ 1git config --global alias.lg &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot; git lg 一下试试。 gitignore 全局配置 新建~/.gitignore文件： 12.DS\_Store *.swp 然后执行： 1$git config --global core.excludesfile ~/.gitignore .gitignore规则不生效 有些时候我们在clone一个项目编译后，往往ide会生成许多文件，我们需要将其加入.gitignore,但我们按照规则添加进去之后往往并不会生效，原因是.gitignore只能忽略那些原来没有被track的文件该文件只能作用于 Untracked Files，也就是那些从来没有被 Git 记录过的文件（自添加以后，从未 add 及 commit 过的文件)，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地 缓存删除（改变成未track状态）： 1git rm --cached ***]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo进阶高级功能配置]]></title>
    <url>%2F2018%2F12%2F19%2FHexo-config%2F</url>
    <content type="text"><![CDATA[进阶高级功能配置更多如外挂一样的功能配置，就直接贴大佬的文章了，哪些功能自己喜欢，按照大佬的教程来配置就行。不过也有坑，比如有些功能（超链接样式、侧栏头像圆形并旋转）可以直接通过在custom.styl添加 CSS 代码实现，无需更改其它文件！ hexo高阶教程next主题优化 hexo的next主题个性化教程:打造炫酷网站 Hexo搭建博客的个性化设置 第一篇文章内有 NexT 主题的文件目录说明，这对自己自定义博客有很大帮助。 更改上一篇，下一篇的顺序进入一篇文章，在文章底部，有上下篇的链接（&lt; &gt;），但是点 &gt; 发现进入的是页面中的的上面那篇文章，与操作习惯不符，别扭。 我猜这是从时间角度设计的，&gt; 英语叫 next，而 next 是更新的。不过别扭就改成习惯的好了，从空间位置角度设计。 方法就是修改文件： 123456789101112131415161718192021222324252627文件位置：~/blog/themes/next/layout/_macro/post.swig&#123;% if not is_index and (post.prev or post.next) %&#125; &lt;div class=&quot;post-nav&quot;&gt; &lt;div class=&quot;post-nav-next post-nav-item&quot;&gt;- &#123;% if post.next %&#125;+ &#123;% if post.prev %&#125;- &lt;a href=&quot;&#123;&#123; url_for(post.next.path) &#125;&#125;&quot; rel=&quot;next&quot; title=&quot;&#123;&#123; post.next.title &#125;&#125;&quot;&gt;+ &lt;a href=&quot;&#123;&#123; url_for(post.prev.path) &#125;&#125;&quot; rel=&quot;prev&quot; title=&quot;&#123;&#123; post.prev.title &#125;&#125;&quot;&gt;- &lt;i class=&quot;fa fa-chevron-left&quot;&gt;&lt;/i&gt; &#123;&#123; post.next.title &#125;&#125;+ &lt;i class=&quot;fa fa-chevron-left&quot;&gt;&lt;/i&gt; &#123;&#123; post.prev.title &#125;&#125; &lt;/a&gt; &#123;% endif %&#125; &lt;/div&gt; &lt;span class=&quot;post-nav-divider&quot;&gt;&lt;/span&gt; &lt;div class=&quot;post-nav-prev post-nav-item&quot;&gt;- &#123;% if post.prev %&#125;+ &#123;% if post.next %&#125;- &lt;a href=&quot;&#123;&#123; url_for(post.prev.path) &#125;&#125;&quot; rel=&quot;prev&quot; title=&quot;&#123;&#123; post.prev.title &#125;&#125;&quot;&gt;+ &lt;a href=&quot;&#123;&#123; url_for(post.next.path) &#125;&#125;&quot; rel=&quot;next&quot; title=&quot;&#123;&#123; post.next.title &#125;&#125;&quot;&gt;- &#123;&#123; post.prev.title &#125;&#125; &lt;i class=&quot;fa fa-chevron-right&quot;&gt;&lt;/i&gt;+ &#123;&#123; post.next.title &#125;&#125; &lt;i class=&quot;fa fa-chevron-right&quot;&gt;&lt;/i&gt; &lt;/a&gt; &#123;% endif %&#125; &lt;/div&gt; &lt;/div&gt;&#123;% endif %&#125; 自己改单词请注意：是 prev 不是 perv，之前自己搞错了，然后盯着电脑屏幕尴尬半天，不停想特么老子哪里错了，怎么特么就是达不到效果！？？？ 移动端显示 back-to-top 按钮和侧栏今天更新一下 NexT 主题，发现已经添加这功能，前提是主题的设计模版是 Muse 或 Mist，然后可以直接在主题配置文件中配置： 12文件位置：~/blog/themes/next/_config.yml# Enable sidebar on narrow viewonmobile: true 如果你发现你的主题配置文件_config.yml中没有这段内容，可以尝试按下面的方法更新主题。 [原方法] 个人感觉在移动端显示侧栏，有利于阅读，我的博客已经改了，你可以将浏览器窗口宽度缩小试试。还好 Google 到了一篇大佬的博客，想改的点击查看吧。 提示：最好还是更新主题，因为这样在移动端点击侧栏之外，侧栏会自动弹回，而按照上面的链接中的文章更改则无法实现。 时间轴页面的年份分隔在 Archives（归档）页面，文章之间有年份分隔，而某一个 category 和 tag 的时间轴页面却没有。怎么办呢？修改两个文件，加代码即可～ category 加到哪？要加两个位置： 12345678910文件位置：~/blog/themes/next/layout/category.swig &#123;% for post in page.posts %&#125; 位置A &#123;&#123; post_template.render(post) &#125;&#125; &#123;% endfor %&#125;...（省略好多行）..位置B（没错最后面） 加什么？绿色的自己看着加： 12345678910111213141516171819202122232425262728文件位置：~/blog/themes/next/layout/category.swig我不要 + 号！ &#123;% for post in page.posts %&#125;++ &#123;# Show year #&#125;+ &#123;% set year %&#125;+ &#123;% set post.year = date(post.date, &apos;YYYY&apos;) %&#125;++ &#123;% if post.year !== year %&#125;+ &#123;% set year = post.year %&#125;+ &lt;div class=&quot;collection-title&quot;&gt;+ &lt;h2 class=&quot;archive-year motion-element&quot; id=&quot;archive-year-&#123;&#123; year &#125;&#125;&quot;&gt;&#123;&#123; year &#125;&#125;&lt;/h2&gt;+ &lt;/div&gt;+ &#123;% endif %&#125;+ &#123;# endshow #&#125;+ &#123;&#123; post_template.render(post) &#125;&#125; &#123;% endfor %&#125;...（省略好多行）..+&#123;% block script_extra %&#125;+ &#123;% if theme.use_motion %&#125;+ &lt;script type=&quot;text/javascript&quot; id=&quot;motion.page.archive&quot;&gt;+ $(&apos;.archive-year&apos;).velocity(&apos;transition.slideLeftIn&apos;);+ &lt;/script&gt;+ &#123;% endif %&#125;+&#123;% endblock %&#125; tag 文件位置：~/blog/themes/next/layout/tag.swig，其它与的 category 修改完全一样。 说明 两段代码直接 Copy 同目录下的 archive.swig 文件里面的，而且 tag.swig 和 category.swig 好像都预留了位置似的，代码小白的我折腾了半天，才改好，不知道写代码的大佬怎么想的w(ﾟДﾟ)w～ 文章底部加上评分小星星 淘宝买东西，作为消费者的我们，看评价很重要。现在作为博主，写了一篇文章，很期待读者的反馈。而与淘宝一样，确认收货后，相比评论，更愿意五星好评。那么博客文章怎么加上呢？ 首先打开主题配置文件： 123456文件位置：~/blog/themes/next/_config.yml# Star rating support to each article.# To get your ID visit https://widgetpack.comrating: enable: true id: color: f79533 先去注释中的网站，首页点 Rating，然后注册个帐号，填一下自己博客的信息，左上角有个 ID，填进主题配置文件中就行，color改成自己喜欢的即可。另： 可以配置评分方式，侧栏 &gt; Rating &gt; Setting，建议用 IP address 或 Device(cookie)，免登录，毕竟 Socials 里面的选项几乎都被墙，不适合国内网络环境。 建议 侧栏 &gt; Site &gt; Setting 中勾选 Private 选项。 上面两步勾选后别忘了点击页面右下方的 SAVE SETTING 绿色按钮保存。 如果感觉上下留白太多，咋整？浏览器 F12 找元素，调成自己喜欢的值，然后 Copy 到custom.styl即可。 经过上面的配置，默认最下面只会显示 5 颗小星星，简洁但不明了，怎么加上文字说明呢？ 首先打开文件： 123456文件位置：~/blog/themes/next/layout/_macro/post.swig &#123;% if theme.rating.enable %&#125; &lt;div class=&quot;wp_rating&quot;&gt;+ &lt;div style=&quot;color: rgba(0, 0, 0, 0.75); font-size:13px; letter-spacing:3px&quot;&gt;(&amp;gt;看完记得五星好评哦亲&amp;lt;)&lt;/div&gt; &lt;div id=&quot;wpac-rating&quot;&gt;&lt;/div&gt; &lt;/div&gt; &#123;% endif %&#125; 然后 Ctrl + F 搜索rating，找到这段，对比我给出的，在绿色这行所示的位置，加上自己想要的说明和样式即可。 侧栏加入已运行的时间我们都有自己的生日，都知道自己的岁数，那为什么不给博客加上，让读者知道博客的年纪呢？操作很简单，而且不是精确到年而是精确到秒，233333～ 首先要加入下面代码: 1234567891011121314151617181920212223242526文件位置：~/blog/themes/next/layout/_custom/sidebar.swig&lt;div id=&quot;days&quot;&gt;&lt;/div&gt;&lt;script&gt;function show_date_time()&#123;window.setTimeout(&quot;show_date_time()&quot;, 1000);BirthDay=new Date(&quot;05/27/2017 15:13:14&quot;);today=new Date();timeold=(today.getTime()-BirthDay.getTime());sectimeold=timeold/1000secondsold=Math.floor(sectimeold);msPerDay=24*60*60*1000e_daysold=timeold/msPerDaydaysold=Math.floor(e_daysold);e_hrsold=(e_daysold-daysold)*24;hrsold=setzero(Math.floor(e_hrsold));e_minsold=(e_hrsold-hrsold)*60;minsold=setzero(Math.floor((e_hrsold-hrsold)*60));seconds=setzero(Math.floor((e_minsold-minsold)*60));document.getElementById(&apos;days&apos;).innerHTML=&quot;已运行&quot;+daysold+&quot;天&quot;+hrsold+&quot;小时&quot;+minsold+&quot;分&quot;+seconds+&quot;秒&quot;;&#125;function setzero(i)&#123;if (i&lt;10)&#123;i=&quot;0&quot; + i&#125;;return i;&#125;show_date_time();&lt;/script&gt; 上面Date的值记得改为你自己的，且按上面格式，然后修改： 1234567891011121314151617181920文件位置：~/blog/themes/next/layout/_macro/sidebar.swig &#123;# Blogroll #&#125; &#123;% if theme.links %&#125; &lt;div class=&quot;links-of-blogroll motion-element &#123;&#123; &quot;links-of-blogroll-&quot; + theme.links_layout | default(&apos;inline&apos;) &#125;&#125;&quot;&gt; &lt;div class=&quot;links-of-blogroll-title&quot;&gt; &lt;i class=&quot;fa fa-fw fa-&#123;&#123; theme.links_icon | default(&apos;globe&apos;) | lower &#125;&#125;&quot;&gt;&lt;/i&gt; &#123;&#123; theme.links_title &#125;&#125;&amp;nbsp; &lt;i class=&quot;fa fa-fw fa-&#123;&#123; theme.links_icon | default(&apos;globe&apos;) | lower &#125;&#125;&quot;&gt;&lt;/i&gt; &lt;/div&gt; &lt;ul class=&quot;links-of-blogroll-list&quot;&gt; &#123;% for name, link in theme.links %&#125; &lt;li class=&quot;links-of-blogroll-item&quot;&gt; &lt;a href=&quot;&#123;&#123; link &#125;&#125;&quot; title=&quot;&#123;&#123; name &#125;&#125;&quot; target=&quot;_blank&quot;&gt;&#123;&#123; name &#125;&#125;&lt;/a&gt; &lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt;+ &#123;% include &apos;../_custom/sidebar.swig&apos; %&#125; &lt;/div&gt; &#123;% endif %&#125;- &#123;% include &apos;../_custom/sidebar.swig&apos; %&#125; 这样就可以了！当然，要是不喜欢颜色，感觉不好看，就可以在上文所提的custom.styl加入： 1234567文件位置：~/blog/themes/next/source/css/_custom/custom.styl// 自定义的侧栏时间样式#days &#123; display: block; color: rgb(7, 179, 155); font-size: 13px; margin-top: 15px;&#125; 里面的值 F12 调成自己喜欢的，然后更改即可。要是不想放在侧栏，想放在页脚，自己应该能折腾了吧～ 添加 TopX 页面博客已有的分类，如 categories 和 tags，都是基于博主的，那么有没有一种分类是基于读者的呢？有，一种是搜索，另一种就是这里的文章阅读量排行榜。 前提是在主题配置文件中配置了 leancloud_visitors。 首先新建页面： 1所在目录：~/blog/hexo new page &quot;top&quot; 然后在主题配置文件中加上菜单 top 和它的 icon： 12文件位置：~/blog/themes/next/_config.ymlmenu: top: /top/ || signal 接着在语言翻译文件中加上菜单 top： 注意：如果你的站点配置文件中的 languages 写的不是 zh-Hans，那么这里请更改相应语言配置文件。 1234567891011文件位置：~/blog/themes/next/languages/zh_Hans.ymlmenu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 schedule: 日程表 sitemap: 站点地图 commonweal: 公益404 top: TopX /* 可以不为 TopX，随便取 */ 最后，编辑第一步新建页面生成的文件：[3] 1234567891011121314151617181920212223242526272829303132文件位置：~/blog/source/top/index.md---title: TopX /* 可以不为 TopX，随便取 */comments: falsekeywords: top,文章阅读量排行榜description: 博客文章阅读量排行榜---&lt;div id=&quot;top&quot;&gt;&lt;/div&gt;&lt;script src=&quot;//cdn1.lncld.net/static/js/3.0.4/av-min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;AV.initialize(&quot;app_id&quot;, &quot;app_key&quot;);&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var time=0 var title=&quot;&quot; var url=&quot;&quot; var query = new AV.Query(&apos;Counter&apos;); query.notEqualTo(&apos;id&apos;,0); query.descending(&apos;time&apos;); query.limit(1000); query.find().then(function (todo) &#123; for (var i=0;i&lt;1000;i++)&#123; var result=todo[i].attributes; time=result.time; title=result.title; url=result.url; var content=&quot;&lt;a href=&apos;&quot;+&quot;https://reuixiy.github.io&quot;+url+&quot;&apos;&gt;&quot;+title+&quot;&lt;/a&gt;&quot;+&quot;&lt;br /&gt;&quot;+&quot;&lt;font color=&apos;#555&apos;&gt;&quot;+&quot;阅读次数：&quot;+time+&quot;&lt;/font&gt;&quot;+&quot;&lt;br /&gt;&lt;br /&gt;&quot;; document.getElementById(&quot;top&quot;).innerHTML+=content &#125; &#125;, function (error) &#123; console.log(&quot;error&quot;); &#125;);&lt;/script&gt;&lt;style&gt;.post-description &#123; display: none; &#125;&lt;/style&gt; 必须将里面的里面的app_id和app_key替换为你的主题配置文件中的值，必须替换里面博客的链接，1000是显示文章的数量，其它可以自己看情况更改。 最后，修改样式可以在custom.styl中加入自定义代码。 Okay! 完成了！ 利用 gulp 压缩代码右键查看网页源代码发现有大量留白，咋整？利用 gulp。 首先任意目录全局安装： 1npm install gulp -g 然后到站点文件夹根目录： 1所在目录：~/blog/npm install gulp gulp-minify-css gulp-htmlmin gulp-htmlclean --save 接着在站点文件夹根目录新建 gulpfile.js： 123456789101112131415161718192021文件位置：~/blog/gulpfile.jsvar gulp = require(&apos;gulp&apos;);var minifycss = require(&apos;gulp-minify-css&apos;);var htmlmin = require(&apos;gulp-htmlmin&apos;);var htmlclean = require(&apos;gulp-htmlclean&apos;);gulp.task(&apos;minify-css&apos;, function() &#123; return gulp.src(&apos;./public/**/*.css&apos;) .pipe(minifycss()) .pipe(gulp.dest(&apos;./public&apos;))&#125;);gulp.task(&apos;minify-html&apos;, function() &#123; return gulp.src(&apos;./public/**/*.html&apos;) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true &#125;)) .pipe(gulp.dest(&apos;./public&apos;))&#125;);gulp.task(&apos;default&apos;, [&apos;minify-html&apos;, &apos;minify-css&apos;]); 最后部署到 GitHub Pages 上查看效果： 1所在目录：~/blog/hexo clean &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo d 我没有压缩 JavaScript，因为我发现会报错，实际也并不需要，因为大部分 JavaScript 都已压缩过。 这里的这段代码执行 gulp 后不支持 hexo s 本地调试，记得在哪看过解决方法，需要的自己 Google。 另外，可能会产生一些奇怪的 bugs，没看到最好，要是看到了的话就自己解决吧～[逃……] 让页脚的心跳动起来世界上有一种伟大的力量，它的名字无人不晓，就是……爱～ 更新 NexT 主题后，发现默认的icon变成了（user），不过这可阻挡不了爱的力量！ 首先编辑主题配置文件： 123文件位置：~/blog/themes/next/_config.ymlfooter:- icon: user+ icon: heart 然后编辑： 12文件位置：~/blog/themes/next/layout/_partials/footer.swig- &lt;span class=&quot;with-love&quot;&gt;+ &lt;span class=&quot;with-love&quot; id=&quot;heart&quot;&gt; 接着编辑custom.styl，加入： 12345678910111213文件位置：~/blog/themes/next/source/css/_custom/custom.styl// 自定义页脚跳动的心样式@keyframes heartAnimate &#123; 0%,100%&#123;transform:scale(1);&#125; 10%,30%&#123;transform:scale(0.9);&#125; 20%,40%,60%,80%&#123;transform:scale(1.1);&#125; 50%,70%&#123;transform:scale(1.1);&#125;&#125;#heart &#123; animation: heartAnimate 1.33s ease-in-out infinite;&#125;.with-love &#123; color: rgb(255, 113, 168);&#125; 页脚加上微信二维码主题默认的微信订阅个人感觉不美观，看到很多网站都是在页脚有个微信的 Logo，然后鼠标移动到上面便会显示二维码，这样感觉很棒。 首先编辑文件，在文件最后加上下面代码： 1234567文件位置：~/blog/themes/next/layout/_partials/footer.swig&lt;div class=&quot;weixin-box&quot;&gt; &lt;div class=&quot;weixin-menu&quot;&gt; &lt;div class=&quot;weixin-hover&quot;&gt; &lt;div class=&quot;weixin-description&quot;&gt;微信扫一扫，订阅本博客&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 然后编辑custom.styl，加入： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051文件位置：~/blog/themes/next/source/css/_custom/custom.styl// 自定义的页脚微信订阅号样式.weixin-box &#123; position: absolute; bottom: 43px; left: 10px; border-radius: 5px; box-shadow: 0px 0px 10px 0px rgba(0, 0, 0, 0.35);&#125;.weixin-menu &#123; position: relative; height: 24px; width: 24px; cursor: pointer; background: url(https://微信的logo.svg); background-size: 24px 24px;&#125;.weixin-hover &#123; position: absolute; bottom: 0px; left: 0px; height: 0px; width: 0px; border-radius: 3px; box-shadow: 0px 0px 10px 0px rgba(0, 0, 0, 0.35); background: url(https://二维码.svg); background-color: #fff; background-repeat: no-repeat; background-size: 150px 150px; transition: all 0.35s ease-in-out; z-index: 1024; opacity: 0;&#125;.weixin-menu:hover .weixin-hover &#123; bottom: 24px; left: 24px; height: 170px; width: 150px; opacity: 1;&#125;.weixin-description &#123; opacity: 0; position: absolute; bottom: 3%; left: 5%; right: 5%; font-size: 12px; transition: all 0.35s cubic-bezier(1, 0, 0, 1);&#125;.weixin-menu:hover .weixin-description &#123; opacity: 1;&#125; 图片务必用矢量图 svg 格式，否则手机上显示效果很差，其它的自己看情况更改。 更改标签云（tagcloud）的颜色如果你和我一样个性化了博客的整体布局颜色，那么默认的标签云页面可能看起来很丑，怎么更改？ 修改下文件： 1文件位置：~/blog/themes/next/layout/page.swig&#123;&#123; tagcloud(&#123;min_font: 13, max_font: 31, amount: 1000, color: true, start_color: &apos;#9733EE&apos;, end_color: &apos;#FF512F&apos;&#125;) &#125;&#125; 修改对应参数值即可，参数说明见 Hexo 官方文档，颜色可以参考这个网站，自己去纠结…… 点击侧栏头像回到博客首页不知道为什么，我看到侧栏头像的第一反应是点击，然后心理预期会跳到博客首页，可惜也仅是预期，那么开始动手吧～ 首先要在主题配置文件中配置好，比如我把头像avatar.gif放在~/blog/source/uploads/下，则： 12345文件位置：~/blog/themes/next/_config.yml# Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gif-#avatar: /images/avatar.gif+avatar: /uploads/avatar.gif 然后编辑文件： 12345文件位置：~/blog/themes/next/layout/_macro/sidebar.swig+ &lt;a href=&quot;/&quot;&gt; &lt;img class=&quot;site-author-image&quot; itemprop=&quot;image&quot; src=&quot;&#123;&#123; url_for( theme.avatar | default(theme.images + &apos;/avatar.gif&apos;) ) &#125;&#125;&quot; alt=&quot;&#123;&#123; theme.author &#125;&#125;&quot; /&gt;+ &lt;/a&gt; 最后就 OK 了～ 文章摘要图片俗话说：“图文并茂”，现实中用笔书写文章实现起来比较困难，但在博客上可以很轻松实现. 首先，文章摘要（excerpt）是指每篇文章在页面（page）上显示的那部分内容，也就是 [Read More] 之前的文章内容。由于它会展示在页面，因此在每篇文章的文章摘要中加一张图片，页面看起来就很美观。 但是有时候可能会出现一个问题：你想从文章中选一张图片作为文章摘要图片，而这张图片由于写作要求，必须添加在文章的末尾，这样点 [Read More] 查看文章时，这张图片就会重复出现了。咋办？ 前提是在主题配置文件中： 1234文件位置：~/blog/themes/next/_config.ymlexcerpt_description: falseauto_excerpt: enable: false 首先加代码： 1234567891011121314151617181920212223242526文件位置：~/blog/themes/next/layout/_macro/post.swig &#123;% if is_index %&#125; &#123;% if post.description and theme.excerpt_description %&#125; &#123;&#123; post.description &#125;&#125; &lt;!--noindex--&gt; &lt;div class=&quot;post-button text-center&quot;&gt; &lt;a class=&quot;btn&quot; href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot;&gt; &#123;&#123; __(&apos;post.read_more&apos;) &#125;&#125; &amp;raquo; &lt;/a&gt; &lt;/div&gt; &lt;!--/noindex--&gt; &#123;% elif post.excerpt %&#125; &#123;&#123; post.excerpt &#125;&#125;+ + &#123;% if post.image %&#125;+ &lt;div class=&quot;out-img-topic&quot;&gt;+ &lt;img src=&#123;&#123; post.image &#125;&#125; class=&quot;img-topic&quot; /&gt;+ &lt;/div&gt;+ &#123;% endif %&#125;+ &lt;!--noindex--&gt; &lt;div class=&quot;post-button text-center&quot;&gt; &lt;a class=&quot;btn&quot; href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&#123;% if theme.scroll_to_more %&#125;#&#123;&#123; __(&apos;post.more&apos;) &#125;&#125;&#123;% endif %&#125;&quot; rel=&quot;contents&quot;&gt; &#123;&#123; __(&apos;post.read_more&apos;) &#125;&#125; &amp;raquo; &lt;/a&gt; &lt;/div&gt; &lt;!--/noindex--&gt; 为了防止有的图片宽度不够导致风格不够统一，页面不美观，需要在custom.styl中加入： 1234文件位置：~/blog/themes/next/source/css/_custom/custom.styl// 自定义的文章摘要图片样式img.img-topic &#123; width: 100%;&#125; 最后编辑有这需求的相关文章时，在Front-matter（文件最上方以---分隔的区域）加上一行： 1image: url url即图片的链接地址～ 文章置顶由于博客的首页可能是被浏览最多的页面，所以首页的前几篇文章被阅读的可能性比较大。可以利用这个特点，通过将自己认为重要的文章放在首页，从而让重要的文章被阅读的可能性增大。 但是，默认的排序只有一个维度——时间，两种选择——正序和倒序，这就造成自己的得意之作被“埋没”了，怎么办呢，如何实现文章的置顶？ NexT 主题以前有过这个功能，然而由于一些bugs（issue）被去掉了。不过在这个丰富的 issue 中，我自己摸索出了一种解决方法，参考了 issue 中的那篇文章。 首先移除默认安装的插件： 1所在目录：~/blog/npm uninstall hexo-generator-index --save 然后安装新插件： 1所在目录：~/blog/npm install hexo-generator-index-pin-top --save 最后编辑有这需求的相关文章时，在Front-matter（文件最上方以---分隔的区域）加上一行： 1top: true 然后就行了，如果你置顶了多篇，怎么控制顺序呢？设置top的值（大的在前面），比如： 1234567# Post a.mdtitle: atop: 1# Post b.mdtitle: btop: 10 那么文章 b 便会显示在文章 a 的前面。 可是，没有任何标记啊，读者怎么知道文章置顶了～ 还好 NexT 原有的置顶功能有考虑到这个，且置顶的样式没有被移除，所以可以直接利用，编辑文件： 12345678910111213141516171819202122232425262728文件位置：~/blog/node_modules/hexo-generator-index-pin-top/lib/generator.js&apos;use strict&apos;;var pagination = require(&apos;hexo-pagination&apos;);module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.sticky &amp;&amp; b.sticky) &#123; // 两篇文章sticky都有定义 if(a.sticky == b.sticky) return b.date - a.date; // 若sticky值一样则按照文章日期降序排 else return b.sticky - a.sticky; // 否则按照sticky值降序排 &#125; else if(a.sticky &amp;&amp; !b.sticky) &#123; // 以下是只有一篇文章sticky有定义，那么将有sticky的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.sticky &amp;&amp; b.sticky) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, &#123; perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: &#123; __index: true &#125; &#125;);&#125;; 也就是将插件的top全部替换为 NexT 原有的sticky，然后将Front-matter中的top替换为sticky，就能调用 NexT 主题原有的置顶样式了。 最后可以自定义一下样式： 12345678910111213文件位置：~/blog/themes/next/source/css/_custom/custom.styl// 自定义的文章置顶样式.post-sticky-flag &#123; font-size: inherit; float: left; color: rgb(0, 0, 0); cursor: help; transition-duration: 0.2s; transition-timing-function: ease-in-out; transition-delay: 0s;&#125;.post-sticky-flag:hover &#123; color: #07b39b;&#125; 已发现的 bug：新安装的插件无法实现站点配置文件中order_by: date，即文章按时间从旧到新排列的配置，也就意味着文章只能按默认的时间从新到旧排列。 背景图片通过 jquery-backstretch，具体操作呢，编辑文件： 12345文件位置：~/blog/themes/next/layout/_layout.swig+ &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js&quot;&gt;&lt;/script&gt;;+ &lt;script&gt;+ $(&quot;body&quot;).backstretch(&quot;https://背景图.jpg&quot;);+ &lt;/script&gt;&lt;/body&gt; 加入到文件最后面&lt;/body&gt;前面即可。 你可以浏览器按 F12 查看我的页面，就可以在&lt;/body&gt;前发现。 幻灯片等更多用法请自行查看 GitHub 上的 README。 动态效果可以在主题配置文件_config.yml里的motion中配置，但是如果你和我一样更改了博客的背景色，可能不能达到很好的效果，怎么办呢？参考这里，修改下面两个文件的相应内容。 ~/blog/themes/next/source/css/_common/components/post/post.styl ~/blog/themes/next/source/js/src/motion.js]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot.JavaMail]]></title>
    <url>%2F2018%2F12%2F01%2FSpringBoot-JavaMail%2F</url>
    <content type="text"><![CDATA[JavaMail是SUN提供给广大Java开发人员的一款邮件发送和接受的一款开源类库，支持常用的邮件协议，如：SMTP、POP3、IMAP，开发人员使用JavaMail编写邮件程序时，不再需要考虑底层的通讯细节如：Socket而是关注在逻辑层面。JavaMail可以发送各种复杂MIME格式的邮件内容，注意JavaMail仅支持JDK4及以上版本。虽然JavaMail是JDK的API但它并没有直接加入JDK中，所以我们需要另外添加依赖。 本章目标将Java提供的JavaMail类库与SpringBoot项目进行整合，并且简单封装下JavaMail类库。 构建项目本章项目无关Web相关内容，所以创建项目时选择Jar形式创建，并且不需要预先导入依赖，项目初始化多余的依赖并没有添加，如果你选择的是War项目也没有关系，那好，我们接下来把我们的主角JavaMail请出来吧，把对应的依赖添加到pom.xml配置文件内。如下所示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-example&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;spring-boot-example&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;--JavaMail--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.mail&lt;/groupId&gt; &lt;artifactId&gt;mail&lt;/artifactId&gt; &lt;version&gt;1.4.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 依赖我们已经导入成功了，接下来我们开始编写JavaMail的封装，我这里简单的对JavaMail做出封装，如果您需要更完美的封装，请对我的代码做出修改即可，先来编写一个MailEntity类来保存发送邮件时需要的参数字段，如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import java.io.Serializable;import java.util.ArrayList;import java.util.List;public class MailEntity implements Serializable &#123; //此处填写SMTP服务器 private String smtpService; //设置端口号 private String smtpPort; //设置发送邮箱地址 private String fromMailAddress; //设置发送邮箱SMTP口令 private String fromMailStmpPwd; //设置邮件标题 private String title; //设置邮件内容 private String content; //内容格式（默认采用html） private String contentType; //接收邮件地址集合 private List&lt;String&gt; list = new ArrayList&lt;&gt;(); public String getSmtpService() &#123; return smtpService; &#125; public void setSmtpService(String smtpService) &#123; this.smtpService = smtpService; &#125; public String getSmtpPort() &#123; return smtpPort; &#125; public void setSmtpPort(String smtpPort) &#123; this.smtpPort = smtpPort; &#125; public String getFromMailAddress() &#123; return fromMailAddress; &#125; public void setFromMailAddress(String fromMailAddress) &#123; this.fromMailAddress = fromMailAddress; &#125; public String getFromMailStmpPwd() &#123; return fromMailStmpPwd; &#125; public void setFromMailStmpPwd(String fromMailStmpPwd) &#123; this.fromMailStmpPwd = fromMailStmpPwd; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125; public String getContentType() &#123; return contentType; &#125; public void setContentType(String contentType) &#123; this.contentType = contentType; &#125; public List&lt;String&gt; getList() &#123; return list; &#125; public void setList(List&lt;String&gt; list) &#123; this.list = list; &#125;&#125; 我们的MailEntity包含了上图3的字段内容，都是一些必填选项，下面我们来创建一个MailSender也就是邮件发送者实体，主要作用就是用来配置发送邮件参数以及执行发送邮件，代码如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121import com.example.springbootexample.Mail.Until.PropertiesUtil;import javax.mail.*;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeMessage;import javax.mail.internet.MimeUtility;import java.util.List;import java.util.Properties;import com.sun.mail.util.MailSSLSocketFactory;public class MailSender &#123; //邮件实体 private static MailEntity mail = new MailEntity(); //设置邮件标题 public MailSender title(String title) &#123; mail.setTitle(title); return this; &#125; //设置邮件内容 public MailSender content(String content) &#123; mail.setContent(content); return this; &#125; //设置邮件格式 public MailSender cpntentType(MailContentEnum typeEnum) &#123; mail.setContentType(typeEnum.getValue()); return this; &#125; //设置请求邮件地址 public MailSender targets(List&lt;String&gt; targets) &#123; mail.setList(targets); return this; &#125; //执行发送邮件 public void send() throws Exception &#123; //默认使用html发送 if (mail.getContentType() == null) &#123; mail.setContentType(MailContentEnum.HTML.getValue()); &#125; if (mail.getTitle() == null || mail.getTitle().trim().length() == 0) &#123; throw new Exception("邮件标题没有设置，请设置有邮件标题"); &#125; if (mail.getContent() == null || mail.getContent().trim().length() == 0) &#123; throw new Exception("邮件内容没有设置，请设置邮件内容"); &#125; if (mail.getList().size() == 0) &#123; throw new Exception("没有接收者邮箱地址"); &#125; //读取/resource/mall_zh_CN.properties中的内容 final PropertiesUtil properties = new PropertiesUtil("mail"); //创建Properties类用于记录邮箱的一些属性 final Properties props = new Properties(); // 关于QQ邮箱，还要设置SSL加密，加上以下代码即可 MailSSLSocketFactory sf = new MailSSLSocketFactory(); sf.setTrustAllHosts(true); props.put("mail.smtp.ssl.enable", "true"); props.put("mail.smtp.ssl.socketFactory", sf); //表示SMTP发送邮件，必须进行身份验证 props.put("mail.smtp.auth", "true"); //此处填写smtp服务器 props.put("mail.smtp.host", properties.getValue("mail.smtp.service")); //设置端口。QQ邮箱给出的俩个端口465//587 props.put("mail.smtp.port", properties.getValue("mail.smtp.port")); //设置发送邮箱 props.put("mail.user", properties.getValue("mail.from.address")); //设置发送邮箱的16位SMTP口令 props.put("mail.password", properties.getValue("mail.from.smtp.pwd")); //构建授权信息，用于进行SMTP省份验证 Authenticator authenticator = new Authenticator() &#123; @Override protected PasswordAuthentication getPasswordAuthentication() &#123; //用户名，密码 String userName = props.getProperty("mail.user"); String passWord = props.getProperty("mail.password"); return new PasswordAuthentication(userName, passWord); &#125; &#125;; //使用环境属性和授权信息，创建邮件会话 Session mailSession = Session.getInstance(props, authenticator); mailSession.setDebug(true); //创建邮件消息 MimeMessage message = new MimeMessage(mailSession); //设置发件人 String nickName = MimeUtility.encodeText(properties.getValue("mail.from.nickname")); InternetAddress form = new InternetAddress(nickName + "&lt;" + props.getProperty("mail.user") + "&gt;"); message.setFrom(form); //设置邮件标题 message.setSubject(mail.getTitle()); //html发送邮件 if (mail.getContentType().equals(MailContentEnum.HTML.getValue())) &#123; //设置邮件标题 message.setContent(mail.getContent(), mail.getContentType()); &#125; //文本发送邮件 else if (mail.getContentType().equals(MailContentEnum.TEXT.getValue())) &#123; message.setText(mail.getContent()); &#125; //发送邮箱地址 List&lt;String&gt; targets = mail.getList(); for (int i = 0; i &lt; targets.size(); i++) &#123; try &#123; //设置收件人的邮箱 InternetAddress to = new InternetAddress(targets.get(i)); message.setRecipients(Message.RecipientType.TO, new InternetAddress[]&#123;to&#125;); //发送邮件 Transport.send(message); &#125; catch (Exception e) &#123; continue; &#125; &#125; &#125;&#125; 因为简书的富文本编辑器不支持代码块，下次编写文章使用MarkDown方式来写，类过长贴起来图挺费劲。上面可以看到我使用到了MailContentTypeEnum以及PropertiesUtil工具类。 MailContentTypeEnum这是一个我自定义的枚举类型，枚举类型包含了邮件内容的类型，目前我仅仅添加了两种，一种是html另外一种则是text形式，具体代码如下所示： 123456789101112131415public enumMailContentEnum &#123; TEXT("text"), HTML("text/html;charset=UTF-8"); private String value; MailContentEnum(String value) &#123; this.value = value; &#125; public String getValue() &#123; return value; &#125;&#125; PropertiesUtilPropertiesUtil是用于读取*.properties配置文件的工具类，使用JavaMail需要配置SMTP以及用户名、密码等也就是MailEntity内的字段，那么我们在/resource目录下创建一个名字叫mail.properties的配置文件，里面存放我们定义的邮件发送参数配置，这样方便修改，我分别贴出PropertiesUtil、mail.properties代码内容，如下所示： 123456789101112131415161718192021import java.util.Locale;import java.util.ResourceBundle;public class PropertiesUtil &#123; private ResourceBundle resource = null; private final String fileName; //获取文件资源对象 public PropertiesUtil(String fileName) &#123; this.fileName = fileName; Locale locale = new Locale("zh", "CN"); this.resource = ResourceBundle.getBundle(this.fileName, locale); &#125; //key value public String getValue(String key) &#123; String message = this.resource.getString(key); return message; &#125;&#125; 12345678910#对应发送服务器的smtp服务器地址mail.smtp.service=smtp.qq.com#对应服务器的smtp服务端口号mail.smtp.port=465#发件人邮箱地址mail.from.address=809962111@qq.com#smtp授权密码mail.from.smtp.pwd= // smtp授权密码#发件人邮箱显示昵称mail.from.nickname=aaa 我使用的QQ邮箱地址作为测试，如果你需要使用你的QQ地址作为测试，请先到QQ邮箱开启POP3/SMTP服务，开启步骤如下。 开启POP3/SMTP第一步：进入邮箱点击“设置”，如下图所示： 第二部：点击“账户”。 第三步：获取授权码。 我的POP3以及SMTP以及开启了所以这里显示的状态是已开启，如果您第一次使用QQ邮箱的SMTP服务，请点击“开启”并且按照提示步骤完成获取“授权码”即可，授权码就是发送邮件参数的smtp.pwd属性。 测试发送邮件我们创建一个sendMailTo类来作为测试入口，因为我们的项目是jar形式，所以我们直接新建一个main方法直接调用发送邮件就可以了，如下所示测试代码： 123456789101112131415161718import com.example.springbootexample.Mail.Config.MailContentEnum;import com.example.springbootexample.Mail.Config.MailSender;import java.util.ArrayList;public class sendMailTo &#123; public static void main(String[] args) throws Exception &#123; new MailSender() .title("测试SpringBoot发送邮件") .content("简单文本内容发送") .cpntentType(MailContentEnum.TEXT) .targets(new ArrayList&lt;String&gt;() &#123;&#123; add("895800655@qq.com"); &#125;&#125;) .send(); &#125;&#125; 我是向我的895800655@qq.com邮箱发送了一条文本类型的测试邮件，发送效果图如下图所示：]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何通过Hexo与GitHub搭建属于自己的博客]]></title>
    <url>%2F2018%2F11%2F28%2FHexoAndGit%2F</url>
    <content type="text"><![CDATA[关于博客写博客对于程序猿来说，应该是个优秀的习惯，个人也觉得蛮高大上的 ^_^。网上的博客论坛网站也多种多样，个人觉得在长久以来的不断竞争淘汰中，各大网站的功能等可能都相差无几了，选择自己稍微偏好的就可以了。 我的个人情况就是结合Hexo和Github Pages的独立个人博客网页，因为听说拥有自己的Github主页也是一件蛮高大上的事 -_- 。 关于Hexo Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Heroku上，是搭建博客的首选框架。这里我们选用的是GitHub，你没看错，全球最大的同性恋交友网站（逃……）。Hexo同时也是GitHub上的开源项目，参见：hexojs/hexo 如果想要更加全面的了解Hexo，可以到其官网 Hexo 了解更多的细节，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。这里，默认各位猿/媛儿都知道GitHub就不再赘述。 关于Github然后简单介绍一下Github以及其Github Pages功能。GitHub是一个面向开源及私有软件项目的托管平台，也是一个分布式版本控制系统，详情见百度百科。说到分布式，自然也有另外一种集中式版本控制系统：SVN，有兴趣小伙伴可以了解百度百科。GIt是SVN的发展版，而且现在主流也是GIt，但某些大公司依然在使用SVN，二者各有优劣，自行体会，此处不做详解，用一张图简单说明： GIthub Pages则是github上的一项功能，可以放置网页文件到指定文件夹，然后给你一个专属域名用于展示一些项目，但现在大多用来开发制作个人博客网站。接下来就一步步按照我曾经的步骤来搭建个人博客，顺便讲讲沿途遇到过的坑，如没有的提及请自行百度。 搭建步骤： 搭建环境准备（包括node.js和git环境，gitHub账户的配置） 配置Hexo 配置GitHub 常用命令 搭建环境 安装git 可以到git官网下载相应平台的版本进行安装。考虑到你可能是无照驾驶，直接在github/git下载。 申请github账号 进入github注册。此处省略一千字。 安装node.js, 到node.js官网下载相应平台的最新版本，傻瓜式安装（自带安装npm）。 安装hexo 打开git bash或者cmd，执行以下命令: 1npm install -g hexo-cli ​ 如果没有错误提示，那么在git的交互环境输入以下命令查看git版本： 1hexo version 配置Hexo首先创建一个文件夹，如blog，用来存放hexo的配置文件等，然后进入blog进行操作。 初始化 右键 git bash，执行以下命令: 1hexo init 安装依赖包 1npm install 生成静态页面 1hexo generate 或者 hexo g 本地运行 1hexo server 或者 hexo s 打开浏览器，在地址栏输入localhost:4000，就可以看到我们搭建好的本地博客了。到此只是搭建好了本地博客，还需要将博客部署到github上。 配置GitHub 新建repository 建立与你用户名对应的仓库，仓库名必须为【 your_username.github.io】 。 部署博客进入你的hexo文件夹根目录下，用编辑器打开_config.yml，修改deploy项，如下（根据你的github进行相应更改）： 1234deploy: type: git #注意：有的版本type是github repo: https://github.com/你的账户名/你的账户名.github.io.git branch: master 此时就完成部署了，用浏览器访问xiaobinhong1.github.io即可(第一次发布可能会有10分钟的延迟)。每次修改完本地的文件后要执行以下命令，重新部署到github上： 123hexo clean hexo generate hexo deploy 或者 hexo d 常用命令1234567hexo new “postName” // 新建文章 hexo new page “pageName” // 新建页面 hexo generate // 生成静态页面至public目录hexo server // 开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy // 将.deploy目录部署到GitHubhexo help // 查看帮助hexo version // 查看Hexo的版本]]></content>
      <categories>
        <category>Hexo</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
