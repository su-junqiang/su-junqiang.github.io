<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F14%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot.JavaMail]]></title>
    <url>%2F2018%2F12%2F01%2FSpringBoot-JavaMail%2F</url>
    <content type="text"><![CDATA[JavaMail是SUN提供给广大Java开发人员的一款邮件发送和接受的一款开源类库，支持常用的邮件协议，如：SMTP、POP3、IMAP，开发人员使用JavaMail编写邮件程序时，不再需要考虑底层的通讯细节如：Socket而是关注在逻辑层面。JavaMail可以发送各种复杂MIME格式的邮件内容，注意JavaMail仅支持JDK4及以上版本。虽然JavaMail是JDK的API但它并没有直接加入JDK中，所以我们需要另外添加依赖。 本章目标将Java提供的JavaMail类库与SpringBoot项目进行整合，并且简单封装下JavaMail类库。 构建项目本章项目无关Web相关内容，所以创建项目时选择Jar形式创建，并且不需要预先导入依赖，项目初始化多余的依赖并没有添加，如果你选择的是War项目也没有关系，那好，我们接下来把我们的主角JavaMail请出来吧，把对应的依赖添加到pom.xml配置文件内。如下所示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-example&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;spring-boot-example&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;--JavaMail--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.mail&lt;/groupId&gt; &lt;artifactId&gt;mail&lt;/artifactId&gt; &lt;version&gt;1.4.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 依赖我们已经导入成功了，接下来我们开始编写JavaMail的封装，我这里简单的对JavaMail做出封装，如果您需要更完美的封装，请对我的代码做出修改即可，先来编写一个MailEntity类来保存发送邮件时需要的参数字段，如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import java.io.Serializable;import java.util.ArrayList;import java.util.List;public class MailEntity implements Serializable &#123; //此处填写SMTP服务器 private String smtpService; //设置端口号 private String smtpPort; //设置发送邮箱地址 private String fromMailAddress; //设置发送邮箱SMTP口令 private String fromMailStmpPwd; //设置邮件标题 private String title; //设置邮件内容 private String content; //内容格式（默认采用html） private String contentType; //接收邮件地址集合 private List&lt;String&gt; list = new ArrayList&lt;&gt;(); public String getSmtpService() &#123; return smtpService; &#125; public void setSmtpService(String smtpService) &#123; this.smtpService = smtpService; &#125; public String getSmtpPort() &#123; return smtpPort; &#125; public void setSmtpPort(String smtpPort) &#123; this.smtpPort = smtpPort; &#125; public String getFromMailAddress() &#123; return fromMailAddress; &#125; public void setFromMailAddress(String fromMailAddress) &#123; this.fromMailAddress = fromMailAddress; &#125; public String getFromMailStmpPwd() &#123; return fromMailStmpPwd; &#125; public void setFromMailStmpPwd(String fromMailStmpPwd) &#123; this.fromMailStmpPwd = fromMailStmpPwd; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125; public String getContentType() &#123; return contentType; &#125; public void setContentType(String contentType) &#123; this.contentType = contentType; &#125; public List&lt;String&gt; getList() &#123; return list; &#125; public void setList(List&lt;String&gt; list) &#123; this.list = list; &#125;&#125; 我们的MailEntity包含了上图3的字段内容，都是一些必填选项，下面我们来创建一个MailSender也就是邮件发送者实体，主要作用就是用来配置发送邮件参数以及执行发送邮件，代码如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121import com.example.springbootexample.Mail.Until.PropertiesUtil;import javax.mail.*;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeMessage;import javax.mail.internet.MimeUtility;import java.util.List;import java.util.Properties;import com.sun.mail.util.MailSSLSocketFactory;public class MailSender &#123; //邮件实体 private static MailEntity mail = new MailEntity(); //设置邮件标题 public MailSender title(String title) &#123; mail.setTitle(title); return this; &#125; //设置邮件内容 public MailSender content(String content) &#123; mail.setContent(content); return this; &#125; //设置邮件格式 public MailSender cpntentType(MailContentEnum typeEnum) &#123; mail.setContentType(typeEnum.getValue()); return this; &#125; //设置请求邮件地址 public MailSender targets(List&lt;String&gt; targets) &#123; mail.setList(targets); return this; &#125; //执行发送邮件 public void send() throws Exception &#123; //默认使用html发送 if (mail.getContentType() == null) &#123; mail.setContentType(MailContentEnum.HTML.getValue()); &#125; if (mail.getTitle() == null || mail.getTitle().trim().length() == 0) &#123; throw new Exception("邮件标题没有设置，请设置有邮件标题"); &#125; if (mail.getContent() == null || mail.getContent().trim().length() == 0) &#123; throw new Exception("邮件内容没有设置，请设置邮件内容"); &#125; if (mail.getList().size() == 0) &#123; throw new Exception("没有接收者邮箱地址"); &#125; //读取/resource/mall_zh_CN.properties中的内容 final PropertiesUtil properties = new PropertiesUtil("mail"); //创建Properties类用于记录邮箱的一些属性 final Properties props = new Properties(); // 关于QQ邮箱，还要设置SSL加密，加上以下代码即可 MailSSLSocketFactory sf = new MailSSLSocketFactory(); sf.setTrustAllHosts(true); props.put("mail.smtp.ssl.enable", "true"); props.put("mail.smtp.ssl.socketFactory", sf); //表示SMTP发送邮件，必须进行身份验证 props.put("mail.smtp.auth", "true"); //此处填写smtp服务器 props.put("mail.smtp.host", properties.getValue("mail.smtp.service")); //设置端口。QQ邮箱给出的俩个端口465//587 props.put("mail.smtp.port", properties.getValue("mail.smtp.port")); //设置发送邮箱 props.put("mail.user", properties.getValue("mail.from.address")); //设置发送邮箱的16位SMTP口令 props.put("mail.password", properties.getValue("mail.from.smtp.pwd")); //构建授权信息，用于进行SMTP省份验证 Authenticator authenticator = new Authenticator() &#123; @Override protected PasswordAuthentication getPasswordAuthentication() &#123; //用户名，密码 String userName = props.getProperty("mail.user"); String passWord = props.getProperty("mail.password"); return new PasswordAuthentication(userName, passWord); &#125; &#125;; //使用环境属性和授权信息，创建邮件会话 Session mailSession = Session.getInstance(props, authenticator); mailSession.setDebug(true); //创建邮件消息 MimeMessage message = new MimeMessage(mailSession); //设置发件人 String nickName = MimeUtility.encodeText(properties.getValue("mail.from.nickname")); InternetAddress form = new InternetAddress(nickName + "&lt;" + props.getProperty("mail.user") + "&gt;"); message.setFrom(form); //设置邮件标题 message.setSubject(mail.getTitle()); //html发送邮件 if (mail.getContentType().equals(MailContentEnum.HTML.getValue())) &#123; //设置邮件标题 message.setContent(mail.getContent(), mail.getContentType()); &#125; //文本发送邮件 else if (mail.getContentType().equals(MailContentEnum.TEXT.getValue())) &#123; message.setText(mail.getContent()); &#125; //发送邮箱地址 List&lt;String&gt; targets = mail.getList(); for (int i = 0; i &lt; targets.size(); i++) &#123; try &#123; //设置收件人的邮箱 InternetAddress to = new InternetAddress(targets.get(i)); message.setRecipients(Message.RecipientType.TO, new InternetAddress[]&#123;to&#125;); //发送邮件 Transport.send(message); &#125; catch (Exception e) &#123; continue; &#125; &#125; &#125;&#125; 因为简书的富文本编辑器不支持代码块，下次编写文章使用MarkDown方式来写，类过长贴起来图挺费劲。上面可以看到我使用到了MailContentTypeEnum以及PropertiesUtil工具类。 MailContentTypeEnum这是一个我自定义的枚举类型，枚举类型包含了邮件内容的类型，目前我仅仅添加了两种，一种是html另外一种则是text形式，具体代码如下所示： 123456789101112131415public enumMailContentEnum &#123; TEXT("text"), HTML("text/html;charset=UTF-8"); private String value; MailContentEnum(String value) &#123; this.value = value; &#125; public String getValue() &#123; return value; &#125;&#125; PropertiesUtilPropertiesUtil是用于读取*.properties配置文件的工具类，使用JavaMail需要配置SMTP以及用户名、密码等也就是MailEntity内的字段，那么我们在/resource目录下创建一个名字叫mail.properties的配置文件，里面存放我们定义的邮件发送参数配置，这样方便修改，我分别贴出PropertiesUtil、mail.properties代码内容，如下所示： 123456789101112131415161718192021import java.util.Locale;import java.util.ResourceBundle;public class PropertiesUtil &#123; private ResourceBundle resource = null; private final String fileName; //获取文件资源对象 public PropertiesUtil(String fileName) &#123; this.fileName = fileName; Locale locale = new Locale("zh", "CN"); this.resource = ResourceBundle.getBundle(this.fileName, locale); &#125; //key value public String getValue(String key) &#123; String message = this.resource.getString(key); return message; &#125;&#125; 12345678910#对应发送服务器的smtp服务器地址mail.smtp.service=smtp.qq.com#对应服务器的smtp服务端口号mail.smtp.port=465#发件人邮箱地址mail.from.address=809962111@qq.com#smtp授权密码mail.from.smtp.pwd= // smtp授权密码#发件人邮箱显示昵称mail.from.nickname=aaa 我使用的QQ邮箱地址作为测试，如果你需要使用你的QQ地址作为测试，请先到QQ邮箱开启POP3/SMTP服务，开启步骤如下。 开启POP3/SMTP第一步：进入邮箱点击“设置”，如下图所示： 第二部：点击“账户”。 第三步：获取授权码。 我的POP3以及SMTP以及开启了所以这里显示的状态是已开启，如果您第一次使用QQ邮箱的SMTP服务，请点击“开启”并且按照提示步骤完成获取“授权码”即可，授权码就是发送邮件参数的smtp.pwd属性。 测试发送邮件我们创建一个sendMailTo类来作为测试入口，因为我们的项目是jar形式，所以我们直接新建一个main方法直接调用发送邮件就可以了，如下所示测试代码： 123456789101112131415161718import com.example.springbootexample.Mail.Config.MailContentEnum;import com.example.springbootexample.Mail.Config.MailSender;import java.util.ArrayList;public class sendMailTo &#123; public static void main(String[] args) throws Exception &#123; new MailSender() .title("测试SpringBoot发送邮件") .content("简单文本内容发送") .cpntentType(MailContentEnum.TEXT) .targets(new ArrayList&lt;String&gt;() &#123;&#123; add("895800655@qq.com"); &#125;&#125;) .send(); &#125;&#125; 我是向我的895800655@qq.com邮箱发送了一条文本类型的测试邮件，发送效果图如下图所示：]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何通过Hexo与GitHub搭建属于自己的博客]]></title>
    <url>%2F2018%2F11%2F28%2FHexoAndGit%2F</url>
    <content type="text"><![CDATA[关于博客写博客对于程序猿来说，应该是个优秀的习惯，个人也觉得蛮高大上的 ^_^。网上的博客论坛网站也多种多样，个人觉得在长久以来的不断竞争淘汰中，各大网站的功能等可能都相差无几了，选择自己稍微偏好的就可以了。 我的个人情况就是结合Hexo和Github Pages的独立个人博客网页，因为听说拥有自己的Github主页也是一件蛮高大上的事 -_- 。 关于Hexo Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Heroku上，是搭建博客的首选框架。这里我们选用的是GitHub，你没看错，全球最大的同性恋交友网站（逃……）。Hexo同时也是GitHub上的开源项目，参见：hexojs/hexo 如果想要更加全面的了解Hexo，可以到其官网 Hexo 了解更多的细节，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。这里，默认各位猿/媛儿都知道GitHub就不再赘述。 关于Github然后简单介绍一下Github以及其Github Pages功能。GitHub是一个面向开源及私有软件项目的托管平台，也是一个分布式版本控制系统，详情见百度百科。说到分布式，自然也有另外一种集中式版本控制系统：SVN，有兴趣小伙伴可以了解百度百科。GIt是SVN的发展版，而且现在主流也是GIt，但某些大公司依然在使用SVN，二者各有优劣，自行体会，此处不做详解，用一张图简单说明： GIthub Pages则是github上的一项功能，可以放置网页文件到指定文件夹，然后给你一个专属域名用于展示一些项目，但现在大多用来开发制作个人博客网站。接下来就一步步按照我曾经的步骤来搭建个人博客，顺便讲讲沿途遇到过的坑，如没有的提及请自行百度。 搭建步骤： 搭建环境准备（包括node.js和git环境，gitHub账户的配置） 配置Hexo 配置GitHub 常用命令 搭建环境 安装git 可以到git官网下载相应平台的版本进行安装。考虑到你可能是无照驾驶，直接在github/git下载。 申请github账号 进入github注册。此处省略一千字。 安装node.js, 到node.js官网下载相应平台的最新版本，傻瓜式安装（自带安装npm）。 安装hexo 打开git bash或者cmd，执行以下命令: 1npm install -g hexo-cli ​ 如果没有错误提示，那么在git的交互环境输入以下命令查看git版本： 1hexo version 配置Hexo首先创建一个文件夹，如blog，用来存放hexo的配置文件等，然后进入blog进行操作。 初始化 右键 git bash，执行以下命令: 1hexo init 安装依赖包 1npm install 生成静态页面 1hexo generate 或者 hexo g 本地运行 1hexo server 或者 hexo s 打开浏览器，在地址栏输入localhost:4000，就可以看到我们搭建好的本地博客了。到此只是搭建好了本地博客，还需要将博客部署到github上。 配置GitHub 新建repository 建立与你用户名对应的仓库，仓库名必须为【 your_username.github.io】 。 部署博客进入你的hexo文件夹根目录下，用编辑器打开_config.yml，修改deploy项，如下（根据你的github进行相应更改）： 1234deploy: type: git #注意：有的版本type是github repo: https://github.com/你的账户名/你的账户名.github.io.git branch: master 此时就完成部署了，用浏览器访问xiaobinhong1.github.io即可(第一次发布可能会有10分钟的延迟)。每次修改完本地的文件后要执行以下命令，重新部署到github上： 123hexo clean hexo generate hexo deploy 或者 hexo d 常用命令1234567hexo new “postName” // 新建文章 hexo new page “pageName” // 新建页面 hexo generate // 生成静态页面至public目录hexo server // 开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy // 将.deploy目录部署到GitHubhexo help // 查看帮助hexo version // 查看Hexo的版本]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
